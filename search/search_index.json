{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"peptidy docs The API documentation for peptidy . Follow these steps to run an mkdocs server on the root of the repository: conda create --name mkdocs conda activate mkdocs python -m pip install mkdocs python -m pip install \"mkdocstrings[python]\" python -m pip install mkdocs-material mkdocs serve","title":"Homepage"},{"location":"#peptidy-docs","text":"The API documentation for peptidy . Follow these steps to run an mkdocs server on the root of the repository: conda create --name mkdocs conda activate mkdocs python -m pip install mkdocs python -m pip install \"mkdocstrings[python]\" python -m pip install mkdocs-material mkdocs serve","title":"peptidy docs"},{"location":"api/biology/","text":"biology A utility module that allows access to the amino acid attributes needed for descriptors and encodings. The entries for all attributes are under the peptidy.data . Attributes: Name Type Description aromatic_aas list A list of aromatic amino acids retrieve based on Lobry,1994 . blosum62_scores dict A dictionary that contains the BLOSUM62 matrix. descriptor_per_aas dict A dictionary that contains the all descriptor values per amino acid. formulas dict A dictionary that contains the closed formulas of the amino acids. hydrophobic_aas list A list of hydrophobic amino acids ( Nelson & Cox, 2004 ). instabilities dict A dictionary that contains the instability of amino acids pairs per Guruprasad, Reddy & Pandit, 1990 . n_h_acceptors dict A dictionary that contains the number of hydrogen acceptors per amino acid according to PubChem . n_h_donors dict A dictionary that contains the number of hydrogen donors per amino acid according to PubChem . n_rotatable_bonds dict A dictionary that contains the number of rotatable bonds in each amino acid ( PubChem ). neg_pks dict A dictionary that contains the negative pKa values of the amino acids. pos_pks dict A dictionary that contains the positive pKa values of the amino acids. token2label dict A dictionary that contains the token to label mapping for label encoding. The amino acids are indexed from 1 to 20 in alphabetical order and the modifications are indexed from 21 to 28. tpsas dict A dictionary that contains the topological polar surface area of the amino acids, as retrieved from Adhav & Saikrishnan, 2023 . weights dict A dictionary that contains the molecular weights of the amino acids. x_logps dict A dictionary that contains the XLogP values of the amino acids per PubChem .","title":"biology"},{"location":"api/biology/#biology","text":"A utility module that allows access to the amino acid attributes needed for descriptors and encodings. The entries for all attributes are under the peptidy.data . Attributes: Name Type Description aromatic_aas list A list of aromatic amino acids retrieve based on Lobry,1994 . blosum62_scores dict A dictionary that contains the BLOSUM62 matrix. descriptor_per_aas dict A dictionary that contains the all descriptor values per amino acid. formulas dict A dictionary that contains the closed formulas of the amino acids. hydrophobic_aas list A list of hydrophobic amino acids ( Nelson & Cox, 2004 ). instabilities dict A dictionary that contains the instability of amino acids pairs per Guruprasad, Reddy & Pandit, 1990 . n_h_acceptors dict A dictionary that contains the number of hydrogen acceptors per amino acid according to PubChem . n_h_donors dict A dictionary that contains the number of hydrogen donors per amino acid according to PubChem . n_rotatable_bonds dict A dictionary that contains the number of rotatable bonds in each amino acid ( PubChem ). neg_pks dict A dictionary that contains the negative pKa values of the amino acids. pos_pks dict A dictionary that contains the positive pKa values of the amino acids. token2label dict A dictionary that contains the token to label mapping for label encoding. The amino acids are indexed from 1 to 20 in alphabetical order and the modifications are indexed from 21 to 28. tpsas dict A dictionary that contains the topological polar surface area of the amino acids, as retrieved from Adhav & Saikrishnan, 2023 . weights dict A dictionary that contains the molecular weights of the amino acids. x_logps dict A dictionary that contains the XLogP values of the amino acids per PubChem .","title":"biology"},{"location":"api/descriptors/","text":"descriptors aliphatic_index ( peptide ) Calculate the aliphatic index of a peptide. The aliphatic index is a measure of the thermal stability of a peptide. It is defined as the volume of a protein that is occupied by aliphatic side chains of amino acids, such as alanine, valine, isoleucine, and leucine ( Ikai, 1980 ). Aliphatic index is calculated as: \\(\\textit{aliphatic_index} = 100 * (f_A + 2.9 f_V + 3.9 f_I + 3.9 f_L)\\) , where \\(f_A\\) , \\(f_V\\) , \\(f_I\\) , and \\(f_L\\) are the frequencies of alanine, valine, isoleucine, and leucine, respectively. Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required Returns: Type Description float The aliphatic index of the peptide. Raises: Type Description ValueError If the peptide sequence contains unknown amino acids or a syntax error. Examples: >>> aliphatic_index ( \"AVIL\" ) 292.5 >>> # doubling the length of the peptide (with no aliphatic amino acids) halves the aliphatic index >>> aliphatic_index ( 'AVILMNPS_p' ) 146.25 >>> aliphatic_index ( \"AKLVT\" ) 156.0 >>> aliphatic_index ( 'ACD' ) 33.3... >>> # Equals to 0, if the peptide contains no aliphatic amino acids >>> aliphatic_index ( \"WYGHP\" ) 0.0 >>> aliphatic_index ( 'DEFR_mSC' ) 0.0 Source code in peptidy/descriptors.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def aliphatic_index ( peptide : str ) -> float : \"\"\" Calculate the aliphatic index of a peptide. The aliphatic index is a measure of the thermal stability of a peptide. It is defined as the volume of a protein that is occupied by aliphatic side chains of amino acids, such as alanine, valine, isoleucine, and leucine ([Ikai, 1980](https://academic.oup.com/jb/article-abstract/88/6/1895/773432?redirectedFrom=fulltext)). Aliphatic index is calculated as: $\\\\textit{aliphatic_index} = 100 * (f_A + 2.9 f_V + 3.9 f_I + 3.9 f_L)$, where $f_A$, $f_V$, $f_I$, and $f_L$ are the frequencies of alanine, valine, isoleucine, and leucine, respectively. Parameters ---------- peptide : str Amino acid sequence of the peptide. Returns ------- float The aliphatic index of the peptide. Raises ------ ValueError If the peptide sequence contains unknown amino acids or a syntax error. Examples -------- >>> aliphatic_index(\"AVIL\") 292.5 >>> # doubling the length of the peptide (with no aliphatic amino acids) halves the aliphatic index >>> aliphatic_index('AVILMNPS_p') 146.25 >>> aliphatic_index(\"AKLVT\") 156.0 >>> aliphatic_index('ACD') 33.3... >>> # Equals to 0, if the peptide contains no aliphatic amino acids >>> aliphatic_index(\"WYGHP\") 0.0 >>> aliphatic_index('DEFR_mSC') 0.0 \"\"\" tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) aa_counts = dict ( Counter ( tokenized_peptide )) aa_counts = { aa : count / length ( peptide ) * 100 for aa , count in aa_counts . items ()} return ( aa_counts . get ( \"A\" , 0 ) + 2.9 * aa_counts . get ( \"V\" , 0 ) + 3.9 * ( aa_counts . get ( \"I\" , 0 ) + aa_counts . get ( \"L\" , 0 )) ) aminoacid_frequencies ( peptide ) Calculate the frequency (count / peptide length) of all amino acids in the input sequence. Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required Returns: Type Description Dict [ str , float ] A dictionary that contains the frequencies of all amino acids and post-translations, not only the ones present in the sequence. The keys have the format freq_<AA> ( AA = letter code of the amino acid). Raises: Type Description ValueError If the peptide sequence contains unknown amino acids or a syntax error. Examples: >>> freqs = aminoacid_frequencies ( \"AVIL\" ) >>> freqs [ \"freq_A\" ] 0.25 >>> freqs [ \"freq_V\" ] 0.25 >>> freqs [ \"freq_C_m\" ] 0.0 >>> freqs [ \"freq_R\" ] 0.0 >>> freqs = aminoacid_frequencies ( 'AC_mD' ) >>> freqs [ \"freq_C_m\" ] 0.3... >>> freqs [ \"freq_D\" ] 0.3... >>> freqs [ \"freq_C\" ] 0.0 >>> freqs [ \"freq_W\" ] 0.0 >>> aminoacid_frequencies ( 'AXR' ) Traceback (most recent call last): ... ValueError : Unknown amino acid(s) in peptide: {'X'} Source code in peptidy/descriptors.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def aminoacid_frequencies ( peptide : str ) -> Dict [ str , float ]: \"\"\" Calculate the frequency (count / peptide length) of all amino acids in the input sequence. Parameters ---------- peptide : str Amino acid sequence of the peptide. Returns ------- Dict[str, float] A dictionary that contains the frequencies of all amino acids and post-translations, not only the ones present in the sequence. The keys have the format `freq_<AA>` (`AA` = letter code of the amino acid). Raises ------ ValueError If the peptide sequence contains unknown amino acids or a syntax error. Examples -------- >>> freqs = aminoacid_frequencies(\"AVIL\") >>> freqs[\"freq_A\"] 0.25 >>> freqs[\"freq_V\"] 0.25 >>> freqs[\"freq_C_m\"] 0.0 >>> freqs[\"freq_R\"] 0.0 >>> freqs = aminoacid_frequencies('AC_mD') >>> freqs[\"freq_C_m\"] 0.3... >>> freqs[\"freq_D\"] 0.3... >>> freqs[\"freq_C\"] 0.0 >>> freqs[\"freq_W\"] 0.0 >>> aminoacid_frequencies('AXR') Traceback (most recent call last): ... ValueError: Unknown amino acid(s) in peptide: {'X'} \"\"\" tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) aa_counts = dict ( Counter ( tokenized_peptide )) peptide_len = length ( tokenized_peptide ) return { f \"freq_ { aa } \" : aa_counts . get ( aa , 0 ) / peptide_len for aa in biology . aminoacids } aromaticity ( peptide ) Calculate the sum of the frequencies of aromatic amino-acids (\"F\", \"W\", \"Y\", and \"Y_p\") as a measure of aromaticity of a peptide ( Lobry,1994 ). Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required Returns: Type Description float Frequency of aromatic residues in the peptide. Raises: Type Description ValueError If the peptide sequence contains unknown amino acids or a syntax error. Examples: >>> aromaticity ( \"AVIL\" ) 0.0 >>> aromaticity ( \"WYGHP\" ) 0.4 >>> aromaticity ( 'ACDEF' ) 0.2 >>> aromaticity ( 'DAY_pCDFWY' ) 0.5 Source code in peptidy/descriptors.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def aromaticity ( peptide : str ) -> float : \"\"\" Calculate the sum of the frequencies of aromatic amino-acids (\"F\", \"W\", \"Y\", and \"Y_p\") as a measure of aromaticity of a peptide ([Lobry,1994](https://academic.oup.com/nar/article-abstract/22/15/3174/1087817)). Parameters ---------- peptide : str Amino acid sequence of the peptide. Returns ------- float Frequency of aromatic residues in the peptide. Raises ------ ValueError If the peptide sequence contains unknown amino acids or a syntax error. Examples -------- >>> aromaticity(\"AVIL\") 0.0 >>> aromaticity(\"WYGHP\") 0.4 >>> aromaticity('ACDEF') 0.2 >>> aromaticity('DAY_pCDFWY') 0.5 \"\"\" peptide = tokenizer . tokenize_peptide ( peptide ) counts = dict ( Counter ( peptide )) return sum ([ counts . get ( aa , 0 ) for aa in biology . aromatic_aas ]) / length ( peptide ) average_n_rotatable_bonds ( peptide ) Calculate the number of total rotatable bonds divided by the number of amino acids in the peptide. Start: Comment By Laura: please check if you agree that the following source is suitable for this descriptor. Also for PubChem I inserted the citation by the PubChem Website itself Chain flexibility is known to play a role in binding [Francesca Peccati & Gonzalo Jim\u00e9nez-Os\u00e9s, 2021]{https://pubs.acs.org/doi/10.1021/acsomega.1c00485}. End comment Laura Start comment Sarah: The source looks good if we want to justify why we have chosen to add this descriptor to the package! If the goal is to only explain where we got the number of rotatable bond from, the Peccati & Jim\u00e9nez-Os\u00e9s citation can be left out. End comment Sarah The number of rotatable bonds per amino acid was retrieved from PubChem Kim et al., 2023 . Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required Returns: Type Description float Average number of rotatable bonds in the peptide. Raises: Type Description ValueError If the peptide sequence contains unknown amino acids or a syntax error. Examples: comment Sarah: I've used rdkit to calculate the number of rotatable bonds for every aa in the sequence, then calculated the average by adding them up and dividing by length(sequence) >>> average_n_rotatable_bonds ( \"AVIL\" ) 2.25 >>> average_n_rotatable_bonds ( \"WYGHP\" ) 2.2 >>> average_n_rotatable_bonds ( 'ACD' ) 2.0 Source code in peptidy/descriptors.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def average_n_rotatable_bonds ( peptide : str , ) -> float : \"\"\" Calculate the number of total rotatable bonds divided by the number of amino acids in the peptide. # Start: Comment By Laura: please check if you agree that the following source is suitable for this descriptor. Also for PubChem I inserted the citation by the PubChem Website itself Chain flexibility is known to play a role in binding [Francesca Peccati & Gonzalo Jim\u00e9nez-Os\u00e9s, 2021]{https://pubs.acs.org/doi/10.1021/acsomega.1c00485}. # End comment Laura # Start comment Sarah: The source looks good if we want to justify why we have chosen to add this descriptor to the package! If the goal is to only explain where we got the number of rotatable bond from, the Peccati & Jim\u00e9nez-Os\u00e9s citation can be left out. # End comment Sarah The number of rotatable bonds per amino acid was retrieved from PubChem [Kim et al., 2023](https://academic.oup.com/nar/article/51/D1/D1373/6777787?login=true). Parameters ---------- peptide : str Amino acid sequence of the peptide. Returns ------- float Average number of rotatable bonds in the peptide. Raises ------ ValueError If the peptide sequence contains unknown amino acids or a syntax error. Examples -------- # comment Sarah: I've used rdkit to calculate the number of rotatable bonds for every aa in the sequence, then calculated the average by adding them up and dividing by length(sequence) >>> average_n_rotatable_bonds(\"AVIL\") 2.25 >>> average_n_rotatable_bonds(\"WYGHP\") 2.2 >>> average_n_rotatable_bonds('ACD') 2.0 \"\"\" tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) return sum ([ biology . n_rotatable_bonds [ aa ] for aa in tokenized_peptide ]) / length ( peptide ) charge ( peptide , pH = 7 ) Calculate the total charge of the sequence. The method used is first described by Bjellqvist [Bjellqvist et al., 1993][https://analyticalsciencejournals.onlinelibrary.wiley.com/doi/10.1002/elps.11501401163]. The total charge is then calculated based on the Henderson-Hasselbach equation Aronson, 1983 . Pka of phosphoserine and phosphothreonine were retrieved from Xie,Jiang & Ben-Amotz, 2005 . Pka of phosphotyrosine was taken from Wojciechowski M et al., 2003 Pka of the posttranslational of arginine was kept equal to the pka of arginine, based on Evich M et al.,2015 Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required pH float , optional pH at which to calculate charge, by default 7. 7 Returns: Type Description float The total charge of the sequence. Examples: >>> charge ( 'ACD' , pH = 13 ) -2.999... >>> charge ( 'NNNNRKTNGDDSLF' ) -2.90... Source code in peptidy/descriptors.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 def charge ( peptide : str , pH : float = 7 ) -> float : \"\"\" Calculate the total charge of the sequence. The method used is first described by Bjellqvist [Bjellqvist et al., 1993][https://analyticalsciencejournals.onlinelibrary.wiley.com/doi/10.1002/elps.11501401163]. The total charge is then calculated based on the Henderson-Hasselbach equation [Aronson, 1983](https://www.sciencedirect.com/science/article/pii/0307441283900468?via%3Dihub). Pka of phosphoserine and phosphothreonine were retrieved from [Xie,Jiang & Ben-Amotz, 2005](https://www.sciencedirect.com/science/article/pii/S0003269705004124?via%3Dihub). Pka of phosphotyrosine was taken from [Wojciechowski M et al., 2003](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1302655/#:~:text=The%20pKa%20value%20for,et%20al.%2C%201994) Pka of the posttranslational of arginine was kept equal to the pka of arginine, based on [Evich M et al.,2015](https://onlinelibrary.wiley.com/doi/full/10.1002/pro.2838) Parameters ---------- peptide : str Amino acid sequence of the peptide. pH : float, optional pH at which to calculate charge, by default 7. Returns ------- float The total charge of the sequence. Examples -------- >>> charge('ACD', pH=13) -2.999... >>> charge('NNNNRKTNGDDSLF') -2.90... \"\"\" tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) aa_counts = dict ( Counter ( tokenized_peptide )) aa_counts [ \"Nterm\" ] = 1.0 aa_counts [ \"Cterm\" ] = 1.0 pos_crs = { aa : 10 ** ( pk - pH ) for aa , pk in biology . pos_pks . items ()} pos_partial_charges = { aa : cr / ( cr + 1 ) for aa , cr in pos_crs . items ()} pos_charge = sum ( [ aa_counts . get ( aa , 0 ) * pc for aa , pc in pos_partial_charges . items ()] ) neg_crs = { aa : 10 ** ( pH - pk ) for aa , pk in biology . neg_pks . items ()} neg_partial_charges = { aa : cr / ( cr + 1 ) for aa , cr in neg_crs . items ()} neg_charge = sum ( [ aa_counts . get ( aa , 0 ) * pc for aa , pc in neg_partial_charges . items ()] ) return pos_charge - neg_charge charge_density ( peptide , pH = 7 ) Calculate the charge of the peptide normalized by weight, i.e., charge / molecular weight. Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required pH float , optional pH at which to calculate charge, by default 7. 7 Returns: Type Description float Charge density. Examples: >>> charge_density ( 'KTT_pNGD' ) 0.0 >>> charge_density ( 'FPAL' , pH = 13 ) -0.25 Source code in peptidy/descriptors.py 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 def charge_density ( peptide : str , pH : float = 7 ) -> float : \"\"\" Calculate the charge of the peptide normalized by weight, *i.e.,* charge / molecular weight. Parameters ---------- peptide : str Amino acid sequence of the peptide. pH : float, optional pH at which to calculate charge, by default 7. Returns ------- float Charge density. Examples -------- >>> charge_density('KTT_pNGD') 0.0 >>> charge_density('FPAL', pH=13) -0.25 \"\"\" return charge ( peptide , pH ) / molecular_weight ( peptide ) compute_descriptors ( peptide , descriptor_names = None , pH = 7 ) Computes multiple descriptors of the peptide. Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required descriptor_names List [ str ], optional A List of descriptor names. If any of the descriptor names is invalid, ValueError is raised. Set to None by default, and computes all descriptors in this case. None pH float , optional pH value to compute charge and charge density (if requested), by default 7 7 Returns: Type Description Dict [ str , Union [ float , int ]] A dictionary that maps descriptor names to their values. Raises: Type Description ValueError ValueError is raised if any of the descriptor names is invalid. Examples: >>> compute_descriptors ( 'ACD' , [ 'charge' , 'charge_density' ], 13 ) {'charge': -3.0, 'charge_density': -1.0} >>> test_output == compute_descriptors ( 'STY' , [ 'molecular_formula' ]) >>> expected_output == { 'n_C' : 16 , 'n_H' : 23 , 'n_N' : 3 , 'n_O' : 7 , 'n_S' : 0 , 'n_P' : 0 } >>> for k , v in test_output . items (): ... assert v == expected_output [ k ] Source code in peptidy/descriptors.py 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 def compute_descriptors ( peptide : str , descriptor_names : List [ str ] = None , pH : float = 7 , ) -> Dict [ str , Union [ float , int ]]: \"\"\"Computes multiple descriptors of the peptide. Parameters ---------- peptide : str Amino acid sequence of the peptide. descriptor_names : List[str], optional A List of descriptor names. If any of the descriptor names is invalid, ValueError is raised. Set to None by default, and computes all descriptors in this case. pH : float, optional pH value to compute charge and charge density (if requested), by default 7 Returns ---------- Dict[str, Union[float, int]] A dictionary that maps descriptor names to their values. Raises ---------- ValueError ValueError is raised if any of the descriptor names is invalid. Examples ---------- >>> compute_descriptors('ACD', ['charge', 'charge_density'], 13) {'charge': -3.0, 'charge_density': -1.0} >>> test_output==compute_descriptors('STY', ['molecular_formula']) >>> expected_output=={'n_C': 16, 'n_H': 23, 'n_N': 3, 'n_O': 7, 'n_S': 0, 'n_P': 0} >>> for k, v in test_output.items(): ... assert v == expected_output[k] \"\"\" if descriptor_names is None : descriptor_names = list ( __DESCRIPTOR_FNS . keys ()) diff = set ( descriptor_names ) - set ( __DESCRIPTOR_FNS . keys ()) if len ( diff ) > 0 : raise ValueError ( f \"Invalid descriptor names: { diff } . Possible names are: { list ( __DESCRIPTOR_FNS . keys ()) } \" ) name_to_descriptor = dict () for name in descriptor_names : if name in [ \"charge\" , \"charge_density\" ]: name_to_descriptor [ name ] = __DESCRIPTOR_FNS [ name ]( peptide , pH = pH ) elif name in [ \"aminoacid_frequencies\" , \"molecular_formula\" ]: name_to_descriptor = { ** name_to_descriptor , ** __DESCRIPTOR_FNS [ name ]( peptide ), } else : name_to_descriptor [ name ] = __DESCRIPTOR_FNS [ name ]( peptide ) return name_to_descriptor hydrophobic_aa_ratio ( peptide ) Calculate the total ratio of hydrophobic amino-acids (A, C, C_m, F, I, L, M, and V) in a peptide. ( Nelson & Cox, 2004 ) Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required Returns: Type Description float Total ratio of hydrophobic amino-acids of the peptide. Examples: >>> hydrophobic_aa_ratio ( 'FC_mPR_mS_pA' ) 0.5 >>> hydrophobic_aa_ratio ( 'FPR_mXS_pA' ) Traceback (most recent call last): ... ValueError : Unknown amino acid(s) in peptide: {'X'} Source code in peptidy/descriptors.py 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 def hydrophobic_aa_ratio ( peptide : str ) -> float : \"\"\" Calculate the total ratio of hydrophobic amino-acids (A, C, C_m, F, I, L, M, and V) in a peptide. ([Nelson & Cox, 2004](https://mis.kp.ac.rw/admin/admin_panel/kp_lms/files/digital/Core%20Books/Core%20Books%20In%20Nursing%20%20And%20%20Midwifery/H106_%20Biochemistry_Lehninger%20Principles%20of%20Biochemistry,%20Fourth%20Edition%20-%20David%20L.%20Nelson,%20Michael%20M.%20Cox.pdf)) Parameters ---------- peptide : str Amino acid sequence of the peptide. Returns ------- float Total ratio of hydrophobic amino-acids of the peptide. Examples -------- >>> hydrophobic_aa_ratio('FC_mPR_mS_pA') 0.5 >>> hydrophobic_aa_ratio('FPR_mXS_pA') Traceback (most recent call last): ... ValueError: Unknown amino acid(s) in peptide: {'X'} \"\"\" tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) aa_counts = dict ( Counter ( tokenized_peptide )) return sum ([ aa_counts . get ( aa , 0 ) for aa in biology . hydrophobic_aas ]) / length ( peptide ) instability_index ( peptide ) Calculate the instability index of the peptide. The instability index is based on amino acid compositions and computed by summing the instability coefficient of all dipeptide combinations in the peptide. It is based on the frequency of the dipeptide occurring in stable versus unstable proteins Guruprasad, Reddy & Pandit, 1990 . A value of 1 is used for amino acid pairs whose instability coefficient is unavailable. Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required Returns: Type Description float Examples: >>> # from https://rdrr.io/cran/Peptides/src/R/boman.R >>> instability_index ( 'ACFEGM' ) 81.566... >>> instability_index ( 'FPP_mS_pA' ) Traceback (most recent call last): ... ValueError : Unknown amino acid(s) in peptide: {'P_m'} Source code in peptidy/descriptors.py 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 def instability_index ( peptide : str ) -> float : \"\"\" Calculate the instability index of the peptide. The instability index is based on amino acid compositions and computed by summing the instability coefficient of all dipeptide combinations in the peptide. It is based on the frequency of the dipeptide occurring in stable versus unstable proteins [Guruprasad, Reddy & Pandit, 1990](https://academic.oup.com/peds/article-abstract/4/2/155/1491271). A value of 1 is used for amino acid pairs whose instability coefficient is unavailable. Parameters ---------- peptide : str Amino acid sequence of the peptide. Returns ------- float Examples -------- >>> # from https://rdrr.io/cran/Peptides/src/R/boman.R >>> instability_index('ACFEGM') 81.566... >>> instability_index('FPP_mS_pA') Traceback (most recent call last): ... ValueError: Unknown amino acid(s) in peptide: {'P_m'} \"\"\" tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) aa_pairs = zip ( tokenized_peptide , tokenized_peptide [ 1 :]) instabilities = [ biology . instabilities [ aa1 ][ aa2 ] for aa1 , aa2 in aa_pairs ] return sum ( instabilities ) * 10 / length ( peptide ) isoelectric_point ( peptide ) Calculate the isoelectric point (pH that the peptide carries no net charge) of the peptide. The isoelectric point is calculated using the peptide charge at different pH values. The method used is based on the Henderson-Hasselbach equation Aronson, 1983 . Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required Returns: Type Description float Isoelectric point of the peptide. Examples: >>> isoelectric_point ( 'ADEFGHI' ) 3.92... >>> isoelectric_point ( 'K_aMSTV' ) 3.44... Source code in peptidy/descriptors.py 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 def isoelectric_point ( peptide : str ) -> float : \"\"\" Calculate the isoelectric point (pH that the peptide carries no net charge) of the peptide. The isoelectric point is calculated using the peptide charge at different pH values. The method used is based on the Henderson-Hasselbach equation [Aronson, 1983](https://www.sciencedirect.com/science/article/pii/0307441283900468?via%3Dihub). Parameters ---------- peptide : str Amino acid sequence of the peptide. Returns ------- float Isoelectric point of the peptide. Examples -------- >>> isoelectric_point('ADEFGHI') 3.92... >>> isoelectric_point('K_aMSTV') 3.44... \"\"\" test_ph = 7 peptide_charge = charge ( peptide , test_ph ) if peptide_charge < 0 : lower_limit , upper_limit = 0 , 7 else : lower_limit , upper_limit = 7 , 14 precision = 10 **- 4 while ( upper_limit - lower_limit ) > precision and abs ( peptide_charge ) > precision : test_ph = ( upper_limit + lower_limit ) / 2 peptide_charge = charge ( peptide , test_ph ) if peptide_charge < 0 : upper_limit = test_ph else : lower_limit = test_ph return test_ph length ( peptide ) Calculate the number of amino acids in the peptide. Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required Returns: Type Description int Number of amino acids in the peptide. Examples: >>> length ( 'ACD' ) 3 >>> length ( 'C_mS_pADDWY' ) 7 >>> length ( 'FP_mS_pA' ) Traceback (most recent call last): ... ValueError : Unknown amino acid(s) in peptide: {'P_m'} Source code in peptidy/descriptors.py 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 def length ( peptide : str ) -> int : \"\"\" Calculate the number of amino acids in the peptide. Parameters ---------- peptide : str Amino acid sequence of the peptide. Returns ------- int Number of amino acids in the peptide. Examples -------- >>> length('ACD') 3 >>> length('C_mS_pADDWY') 7 >>> length('FP_mS_pA') Traceback (most recent call last): ... ValueError: Unknown amino acid(s) in peptide: {'P_m'} \"\"\" return len ( tokenizer . tokenize_peptide ( peptide )) molecular_formula ( peptide ) Determine the closed molecular formula of the amino acid sequence of the peptide. The peptide bonds between amino acids are included in the formula. Molecular formulas were retrieved from PubChem . Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required Returns: Type Description Dict [ str , int ] Count of each element in the peptide where the element symbols are keys and counts are values. The keys have the format n_<element> ( element = element symbol). Examples: >>> formula = molecular_formula ( 'ADEF' ) >>> formula [ 'n_H' ] 28 >>> formula [ 'n_O' ] 9 >>> formula [ 'n_S' ] 0 >>> formula = molecular_formula ( 'PTHRAAPDES' ) >>> formula [ 'n_H' ] 69 >>> formula [ 'n_O' ] 17 >>> formula [ 'n_S' ] 0 Source code in peptidy/descriptors.py 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 def molecular_formula ( peptide : str , ) -> Dict [ str , int ]: \"\"\" Determine the closed molecular formula of the amino acid sequence of the peptide. The peptide bonds between amino acids are included in the formula. Molecular formulas were retrieved from [PubChem](https://pubchem.ncbi.nlm.nih.gov/). Parameters ---------- peptide : str Amino acid sequence of the peptide. Returns ------- Dict[str, int] Count of each element in the peptide where the element symbols are keys and counts are values. The keys have the format `n_<element>` (`element` = element symbol). Examples -------- >>> formula = molecular_formula('ADEF') >>> formula['n_H'] 28 >>> formula['n_O'] 9 >>> formula['n_S'] 0 >>> formula = molecular_formula('PTHRAAPDES') >>> formula['n_H'] 69 >>> formula['n_O'] 17 >>> formula['n_S'] 0 \"\"\" tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) aa_formulas = [ Counter ( biology . formulas [ aa ]) for aa in tokenized_peptide ] elements = [ \"C\" , \"H\" , \"N\" , \"O\" , \"S\" , \"P\" ] peptide_formula = dict () for element in elements : peptide_formula [ f \"n_ { element } \" ] = sum ( [ formula [ element ] for formula in aa_formulas ] ) peptide_formula [ \"n_H\" ] = peptide_formula [ \"n_H\" ] - 2 * length ( peptide ) + 2 peptide_formula [ \"n_O\" ] = peptide_formula [ \"n_O\" ] - length ( peptide ) + 1 return peptide_formula molecular_weight ( peptide ) Calculate the weight (g/mol) of the peptide without peptide bonds. The molecular weight of the peptide is calculated by summing the weights of the amino acids and subtracting the weight of water for each peptide bond. Molecular weight were retrieved from PubChem . Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required Returns: Type Description float Molecular weight of the peptide. Examples: >>> molecular_weight ( 'RMK_aS_pCD' ) 860.885 >>> molecular_weight ( 'DEGHI' ) 569.56 Source code in peptidy/descriptors.py 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 def molecular_weight ( peptide : str ) -> float : \"\"\" Calculate the weight (g/mol) of the peptide without peptide bonds. The molecular weight of the peptide is calculated by summing the weights of the amino acids and subtracting the weight of water for each peptide bond. Molecular weight were retrieved from [PubChem](https://pubchem.ncbi.nlm.nih.gov/). Parameters ---------- peptide : str Amino acid sequence of the peptide. Returns ------- float Molecular weight of the peptide. Examples -------- >>> molecular_weight('RMK_aS_pCD') 860.885 >>> molecular_weight('DEGHI') 569.56 \"\"\" tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) total_weight = sum ([ biology . weights [ aa ] for aa in tokenized_peptide ]) return total_weight - 18.015 * ( length ( peptide ) - 1 ) n_h_acceptors ( peptide ) Calculate the total number of hydrogen bond acceptors in the peptide. The number of hydrogen bond acceptors in the peptide is calculated by summing the number of hydrogen bond acceptors. Hydrogen bonds are important in protein-protein interactions Hubbard & Haider, 2010 . The number of hydrogen bond acceptors for each amino acid were retrieved from PubChem . Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required Returns: Type Description float Total number of hydrogen bond acceptors in the peptide. Examples: >>> n_h_acceptors ( 'FSCA' ) 14 >>> n_h_acceptors ( 'FXS_pGNM' ) Traceback (most recent call last): ... ValueError : Unknown amino acid(s) in peptide: {'X'} Source code in peptidy/descriptors.py 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 def n_h_acceptors ( peptide : str ) -> float : \"\"\" Calculate the total number of hydrogen bond acceptors in the peptide. The number of hydrogen bond acceptors in the peptide is calculated by summing the number of hydrogen bond acceptors. Hydrogen bonds are important in protein-protein interactions [Hubbard & Haider, 2010](https://doi.org/10.1002/9780470015902.a0003011.pub2). The number of hydrogen bond acceptors for each amino acid were retrieved from [PubChem](https://pubchem.ncbi.nlm.nih.gov/). Parameters ---------- peptide : str Amino acid sequence of the peptide. Returns ------- float Total number of hydrogen bond acceptors in the peptide. Examples -------- >>> n_h_acceptors('FSCA') 14 >>> n_h_acceptors('FXS_pGNM') Traceback (most recent call last): ... ValueError: Unknown amino acid(s) in peptide: {'X'} \"\"\" tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) return sum ([ biology . n_h_acceptors [ aa ] for aa in tokenized_peptide ]) n_h_donors ( peptide ) Calculate the total number of hydrogen bond donors in the peptide. Hydrogen bonds are important in protein-protein interactions Hubbard & Haider, 2010 . The number of hydrogen bond donors for each amino acid were retrieved from PubChem . Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required Returns: Type Description float Total number of hydrogen bond donors in the peptide. Examples: >>> n_h_donors ( 'VYP' ) 7 >>> n_h_donors ( 'PGU' ) Traceback (most recent call last): ... ValueError : Unknown amino acid(s) in peptide: {'U'} Source code in peptidy/descriptors.py 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 def n_h_donors ( peptide : str ) -> float : \"\"\" Calculate the total number of hydrogen bond donors in the peptide. Hydrogen bonds are important in protein-protein interactions [Hubbard & Haider, 2010](https://doi.org/10.1002/9780470015902.a0003011.pub2). The number of hydrogen bond donors for each amino acid were retrieved from [PubChem](https://pubchem.ncbi.nlm.nih.gov/). Parameters ---------- peptide : str Amino acid sequence of the peptide. Returns ------- float Total number of hydrogen bond donors in the peptide. Examples -------- >>> n_h_donors('VYP') 7 >>> n_h_donors('PGU') Traceback (most recent call last): ... ValueError: Unknown amino acid(s) in peptide: {'U'} \"\"\" tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) return sum ([ biology . n_h_donors [ aa ] for aa in tokenized_peptide ]) topological_polar_surface_area ( peptide ) Calculate the total topological polar surface area of the peptide. The topological polar surface area relates to the Van der Waals forces Adhav & Saikrishnan, 2023 . Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required Returns: Type Description float Total topological polar surface area of the peptide. Examples: >>> topological_polar_surface_area ( 'R_dPSRMNPAWE' ) 853.19... >>> topological_polar_surface_area ( 'AYZ' ) Traceback (most recent call last): ... ValueError : Unknown amino acid(s) in peptide: {'Z'} Source code in peptidy/descriptors.py 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 def topological_polar_surface_area ( peptide : str , ) -> float : \"\"\" Calculate the total topological polar surface area of the peptide. The topological polar surface area relates to the Van der Waals forces [Adhav & Saikrishnan, 2023](https://pubs.acs.org/doi/10.1021/acsomega.3c00205). Parameters ---------- peptide : str Amino acid sequence of the peptide. Returns ---------- float Total topological polar surface area of the peptide. Examples ---------- >>> topological_polar_surface_area('R_dPSRMNPAWE') 853.19... >>> topological_polar_surface_area('AYZ') Traceback (most recent call last): ... ValueError: Unknown amino acid(s) in peptide: {'Z'} \"\"\" tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) total_surface = sum ([ biology . tpsas [ aa ] for aa in tokenized_peptide ]) return total_surface x_logp_energy ( peptide ) Calculate the sum of xlogP index of the peptide divided by the length of the peptide. The xlogP index is a measure of the hydrophobicity of the peptide Chen et al, 2007 and the indices per amino acid was retrieved from PubChem . Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required Returns: Type Description float xlogP index of the peptide. Examples: >>> x_logp_energy ( 'R_dPSRMNPAWE' ) 2.9 >>> x_logp_energy ( 'BCAF' ) Traceback (most recent call last): ... ValueError : Unknown amino acid(s) in peptide: {'B'} Source code in peptidy/descriptors.py 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 def x_logp_energy ( peptide : str ) -> float : \"\"\" Calculate the sum of xlogP index of the peptide divided by the length of the peptide. The xlogP index is a measure of the hydrophobicity of the peptide [Chen et al, 2007](https://pubs.acs.org/doi/10.1021/ci700257y) and the indices per amino acid was retrieved from [PubChem](https://pubchem.ncbi.nlm.nih.gov/). Parameters ---------- peptide : str Amino acid sequence of the peptide. Returns ---------- float xlogP index of the peptide. Examples ---------- >>> x_logp_energy('R_dPSRMNPAWE') 2.9 >>> x_logp_energy('BCAF') Traceback (most recent call last): ... ValueError: Unknown amino acid(s) in peptide: {'B'} \"\"\" tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) energy = sum ([ - biology . x_logps [ aa ] for aa in tokenized_peptide ]) return energy / length ( peptide )","title":"descriptors"},{"location":"api/descriptors/#descriptors","text":"","title":"descriptors"},{"location":"api/descriptors/#peptidy.descriptors.aliphatic_index","text":"Calculate the aliphatic index of a peptide. The aliphatic index is a measure of the thermal stability of a peptide. It is defined as the volume of a protein that is occupied by aliphatic side chains of amino acids, such as alanine, valine, isoleucine, and leucine ( Ikai, 1980 ). Aliphatic index is calculated as: \\(\\textit{aliphatic_index} = 100 * (f_A + 2.9 f_V + 3.9 f_I + 3.9 f_L)\\) , where \\(f_A\\) , \\(f_V\\) , \\(f_I\\) , and \\(f_L\\) are the frequencies of alanine, valine, isoleucine, and leucine, respectively. Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required Returns: Type Description float The aliphatic index of the peptide. Raises: Type Description ValueError If the peptide sequence contains unknown amino acids or a syntax error. Examples: >>> aliphatic_index ( \"AVIL\" ) 292.5 >>> # doubling the length of the peptide (with no aliphatic amino acids) halves the aliphatic index >>> aliphatic_index ( 'AVILMNPS_p' ) 146.25 >>> aliphatic_index ( \"AKLVT\" ) 156.0 >>> aliphatic_index ( 'ACD' ) 33.3... >>> # Equals to 0, if the peptide contains no aliphatic amino acids >>> aliphatic_index ( \"WYGHP\" ) 0.0 >>> aliphatic_index ( 'DEFR_mSC' ) 0.0 Source code in peptidy/descriptors.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def aliphatic_index ( peptide : str ) -> float : \"\"\" Calculate the aliphatic index of a peptide. The aliphatic index is a measure of the thermal stability of a peptide. It is defined as the volume of a protein that is occupied by aliphatic side chains of amino acids, such as alanine, valine, isoleucine, and leucine ([Ikai, 1980](https://academic.oup.com/jb/article-abstract/88/6/1895/773432?redirectedFrom=fulltext)). Aliphatic index is calculated as: $\\\\textit{aliphatic_index} = 100 * (f_A + 2.9 f_V + 3.9 f_I + 3.9 f_L)$, where $f_A$, $f_V$, $f_I$, and $f_L$ are the frequencies of alanine, valine, isoleucine, and leucine, respectively. Parameters ---------- peptide : str Amino acid sequence of the peptide. Returns ------- float The aliphatic index of the peptide. Raises ------ ValueError If the peptide sequence contains unknown amino acids or a syntax error. Examples -------- >>> aliphatic_index(\"AVIL\") 292.5 >>> # doubling the length of the peptide (with no aliphatic amino acids) halves the aliphatic index >>> aliphatic_index('AVILMNPS_p') 146.25 >>> aliphatic_index(\"AKLVT\") 156.0 >>> aliphatic_index('ACD') 33.3... >>> # Equals to 0, if the peptide contains no aliphatic amino acids >>> aliphatic_index(\"WYGHP\") 0.0 >>> aliphatic_index('DEFR_mSC') 0.0 \"\"\" tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) aa_counts = dict ( Counter ( tokenized_peptide )) aa_counts = { aa : count / length ( peptide ) * 100 for aa , count in aa_counts . items ()} return ( aa_counts . get ( \"A\" , 0 ) + 2.9 * aa_counts . get ( \"V\" , 0 ) + 3.9 * ( aa_counts . get ( \"I\" , 0 ) + aa_counts . get ( \"L\" , 0 )) )","title":"aliphatic_index()"},{"location":"api/descriptors/#peptidy.descriptors.aminoacid_frequencies","text":"Calculate the frequency (count / peptide length) of all amino acids in the input sequence. Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required Returns: Type Description Dict [ str , float ] A dictionary that contains the frequencies of all amino acids and post-translations, not only the ones present in the sequence. The keys have the format freq_<AA> ( AA = letter code of the amino acid). Raises: Type Description ValueError If the peptide sequence contains unknown amino acids or a syntax error. Examples: >>> freqs = aminoacid_frequencies ( \"AVIL\" ) >>> freqs [ \"freq_A\" ] 0.25 >>> freqs [ \"freq_V\" ] 0.25 >>> freqs [ \"freq_C_m\" ] 0.0 >>> freqs [ \"freq_R\" ] 0.0 >>> freqs = aminoacid_frequencies ( 'AC_mD' ) >>> freqs [ \"freq_C_m\" ] 0.3... >>> freqs [ \"freq_D\" ] 0.3... >>> freqs [ \"freq_C\" ] 0.0 >>> freqs [ \"freq_W\" ] 0.0 >>> aminoacid_frequencies ( 'AXR' ) Traceback (most recent call last): ... ValueError : Unknown amino acid(s) in peptide: {'X'} Source code in peptidy/descriptors.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def aminoacid_frequencies ( peptide : str ) -> Dict [ str , float ]: \"\"\" Calculate the frequency (count / peptide length) of all amino acids in the input sequence. Parameters ---------- peptide : str Amino acid sequence of the peptide. Returns ------- Dict[str, float] A dictionary that contains the frequencies of all amino acids and post-translations, not only the ones present in the sequence. The keys have the format `freq_<AA>` (`AA` = letter code of the amino acid). Raises ------ ValueError If the peptide sequence contains unknown amino acids or a syntax error. Examples -------- >>> freqs = aminoacid_frequencies(\"AVIL\") >>> freqs[\"freq_A\"] 0.25 >>> freqs[\"freq_V\"] 0.25 >>> freqs[\"freq_C_m\"] 0.0 >>> freqs[\"freq_R\"] 0.0 >>> freqs = aminoacid_frequencies('AC_mD') >>> freqs[\"freq_C_m\"] 0.3... >>> freqs[\"freq_D\"] 0.3... >>> freqs[\"freq_C\"] 0.0 >>> freqs[\"freq_W\"] 0.0 >>> aminoacid_frequencies('AXR') Traceback (most recent call last): ... ValueError: Unknown amino acid(s) in peptide: {'X'} \"\"\" tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) aa_counts = dict ( Counter ( tokenized_peptide )) peptide_len = length ( tokenized_peptide ) return { f \"freq_ { aa } \" : aa_counts . get ( aa , 0 ) / peptide_len for aa in biology . aminoacids }","title":"aminoacid_frequencies()"},{"location":"api/descriptors/#peptidy.descriptors.aromaticity","text":"Calculate the sum of the frequencies of aromatic amino-acids (\"F\", \"W\", \"Y\", and \"Y_p\") as a measure of aromaticity of a peptide ( Lobry,1994 ). Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required Returns: Type Description float Frequency of aromatic residues in the peptide. Raises: Type Description ValueError If the peptide sequence contains unknown amino acids or a syntax error. Examples: >>> aromaticity ( \"AVIL\" ) 0.0 >>> aromaticity ( \"WYGHP\" ) 0.4 >>> aromaticity ( 'ACDEF' ) 0.2 >>> aromaticity ( 'DAY_pCDFWY' ) 0.5 Source code in peptidy/descriptors.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def aromaticity ( peptide : str ) -> float : \"\"\" Calculate the sum of the frequencies of aromatic amino-acids (\"F\", \"W\", \"Y\", and \"Y_p\") as a measure of aromaticity of a peptide ([Lobry,1994](https://academic.oup.com/nar/article-abstract/22/15/3174/1087817)). Parameters ---------- peptide : str Amino acid sequence of the peptide. Returns ------- float Frequency of aromatic residues in the peptide. Raises ------ ValueError If the peptide sequence contains unknown amino acids or a syntax error. Examples -------- >>> aromaticity(\"AVIL\") 0.0 >>> aromaticity(\"WYGHP\") 0.4 >>> aromaticity('ACDEF') 0.2 >>> aromaticity('DAY_pCDFWY') 0.5 \"\"\" peptide = tokenizer . tokenize_peptide ( peptide ) counts = dict ( Counter ( peptide )) return sum ([ counts . get ( aa , 0 ) for aa in biology . aromatic_aas ]) / length ( peptide )","title":"aromaticity()"},{"location":"api/descriptors/#peptidy.descriptors.average_n_rotatable_bonds","text":"Calculate the number of total rotatable bonds divided by the number of amino acids in the peptide.","title":"average_n_rotatable_bonds()"},{"location":"api/descriptors/#peptidy.descriptors.average_n_rotatable_bonds--start-comment-by-laura-please-check-if-you-agree-that-the-following-source-is-suitable-for-this-descriptor-also-for-pubchem-i-inserted-the-citation-by-the-pubchem-website-itself","text":"Chain flexibility is known to play a role in binding [Francesca Peccati & Gonzalo Jim\u00e9nez-Os\u00e9s, 2021]{https://pubs.acs.org/doi/10.1021/acsomega.1c00485}.","title":"Start: Comment By Laura: please check if you agree that the following source is suitable for this descriptor. Also for PubChem I inserted the citation by the PubChem Website itself"},{"location":"api/descriptors/#peptidy.descriptors.average_n_rotatable_bonds--end-comment-laura","text":"","title":"End comment Laura"},{"location":"api/descriptors/#peptidy.descriptors.average_n_rotatable_bonds--start-comment-sarah-the-source-looks-good-if-we-want-to-justify-why-we-have-chosen-to-add-this-descriptor-to-the-package","text":"If the goal is to only explain where we got the number of rotatable bond from, the Peccati & Jim\u00e9nez-Os\u00e9s citation can be left out.","title":"Start comment Sarah: The source looks good if we want to justify why we have chosen to add this descriptor to the package!"},{"location":"api/descriptors/#peptidy.descriptors.average_n_rotatable_bonds--end-comment-sarah","text":"The number of rotatable bonds per amino acid was retrieved from PubChem Kim et al., 2023 . Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required Returns: Type Description float Average number of rotatable bonds in the peptide. Raises: Type Description ValueError If the peptide sequence contains unknown amino acids or a syntax error. Examples:","title":"End comment Sarah"},{"location":"api/descriptors/#peptidy.descriptors.average_n_rotatable_bonds--comment-sarah-ive-used-rdkit-to-calculate-the-number-of-rotatable-bonds-for-every-aa-in-the-sequence-then-calculated-the-average-by-adding-them-up-and-dividing-by-lengthsequence","text":">>> average_n_rotatable_bonds ( \"AVIL\" ) 2.25 >>> average_n_rotatable_bonds ( \"WYGHP\" ) 2.2 >>> average_n_rotatable_bonds ( 'ACD' ) 2.0 Source code in peptidy/descriptors.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def average_n_rotatable_bonds ( peptide : str , ) -> float : \"\"\" Calculate the number of total rotatable bonds divided by the number of amino acids in the peptide. # Start: Comment By Laura: please check if you agree that the following source is suitable for this descriptor. Also for PubChem I inserted the citation by the PubChem Website itself Chain flexibility is known to play a role in binding [Francesca Peccati & Gonzalo Jim\u00e9nez-Os\u00e9s, 2021]{https://pubs.acs.org/doi/10.1021/acsomega.1c00485}. # End comment Laura # Start comment Sarah: The source looks good if we want to justify why we have chosen to add this descriptor to the package! If the goal is to only explain where we got the number of rotatable bond from, the Peccati & Jim\u00e9nez-Os\u00e9s citation can be left out. # End comment Sarah The number of rotatable bonds per amino acid was retrieved from PubChem [Kim et al., 2023](https://academic.oup.com/nar/article/51/D1/D1373/6777787?login=true). Parameters ---------- peptide : str Amino acid sequence of the peptide. Returns ------- float Average number of rotatable bonds in the peptide. Raises ------ ValueError If the peptide sequence contains unknown amino acids or a syntax error. Examples -------- # comment Sarah: I've used rdkit to calculate the number of rotatable bonds for every aa in the sequence, then calculated the average by adding them up and dividing by length(sequence) >>> average_n_rotatable_bonds(\"AVIL\") 2.25 >>> average_n_rotatable_bonds(\"WYGHP\") 2.2 >>> average_n_rotatable_bonds('ACD') 2.0 \"\"\" tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) return sum ([ biology . n_rotatable_bonds [ aa ] for aa in tokenized_peptide ]) / length ( peptide )","title":"comment Sarah: I've used rdkit to calculate the number of rotatable bonds for every aa in the sequence, then calculated the average by adding them up and dividing by length(sequence)"},{"location":"api/descriptors/#peptidy.descriptors.charge","text":"Calculate the total charge of the sequence. The method used is first described by Bjellqvist [Bjellqvist et al., 1993][https://analyticalsciencejournals.onlinelibrary.wiley.com/doi/10.1002/elps.11501401163]. The total charge is then calculated based on the Henderson-Hasselbach equation Aronson, 1983 . Pka of phosphoserine and phosphothreonine were retrieved from Xie,Jiang & Ben-Amotz, 2005 . Pka of phosphotyrosine was taken from Wojciechowski M et al., 2003 Pka of the posttranslational of arginine was kept equal to the pka of arginine, based on Evich M et al.,2015 Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required pH float , optional pH at which to calculate charge, by default 7. 7 Returns: Type Description float The total charge of the sequence. Examples: >>> charge ( 'ACD' , pH = 13 ) -2.999... >>> charge ( 'NNNNRKTNGDDSLF' ) -2.90... Source code in peptidy/descriptors.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 def charge ( peptide : str , pH : float = 7 ) -> float : \"\"\" Calculate the total charge of the sequence. The method used is first described by Bjellqvist [Bjellqvist et al., 1993][https://analyticalsciencejournals.onlinelibrary.wiley.com/doi/10.1002/elps.11501401163]. The total charge is then calculated based on the Henderson-Hasselbach equation [Aronson, 1983](https://www.sciencedirect.com/science/article/pii/0307441283900468?via%3Dihub). Pka of phosphoserine and phosphothreonine were retrieved from [Xie,Jiang & Ben-Amotz, 2005](https://www.sciencedirect.com/science/article/pii/S0003269705004124?via%3Dihub). Pka of phosphotyrosine was taken from [Wojciechowski M et al., 2003](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1302655/#:~:text=The%20pKa%20value%20for,et%20al.%2C%201994) Pka of the posttranslational of arginine was kept equal to the pka of arginine, based on [Evich M et al.,2015](https://onlinelibrary.wiley.com/doi/full/10.1002/pro.2838) Parameters ---------- peptide : str Amino acid sequence of the peptide. pH : float, optional pH at which to calculate charge, by default 7. Returns ------- float The total charge of the sequence. Examples -------- >>> charge('ACD', pH=13) -2.999... >>> charge('NNNNRKTNGDDSLF') -2.90... \"\"\" tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) aa_counts = dict ( Counter ( tokenized_peptide )) aa_counts [ \"Nterm\" ] = 1.0 aa_counts [ \"Cterm\" ] = 1.0 pos_crs = { aa : 10 ** ( pk - pH ) for aa , pk in biology . pos_pks . items ()} pos_partial_charges = { aa : cr / ( cr + 1 ) for aa , cr in pos_crs . items ()} pos_charge = sum ( [ aa_counts . get ( aa , 0 ) * pc for aa , pc in pos_partial_charges . items ()] ) neg_crs = { aa : 10 ** ( pH - pk ) for aa , pk in biology . neg_pks . items ()} neg_partial_charges = { aa : cr / ( cr + 1 ) for aa , cr in neg_crs . items ()} neg_charge = sum ( [ aa_counts . get ( aa , 0 ) * pc for aa , pc in neg_partial_charges . items ()] ) return pos_charge - neg_charge","title":"charge()"},{"location":"api/descriptors/#peptidy.descriptors.charge_density","text":"Calculate the charge of the peptide normalized by weight, i.e., charge / molecular weight. Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required pH float , optional pH at which to calculate charge, by default 7. 7 Returns: Type Description float Charge density. Examples: >>> charge_density ( 'KTT_pNGD' ) 0.0 >>> charge_density ( 'FPAL' , pH = 13 ) -0.25 Source code in peptidy/descriptors.py 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 def charge_density ( peptide : str , pH : float = 7 ) -> float : \"\"\" Calculate the charge of the peptide normalized by weight, *i.e.,* charge / molecular weight. Parameters ---------- peptide : str Amino acid sequence of the peptide. pH : float, optional pH at which to calculate charge, by default 7. Returns ------- float Charge density. Examples -------- >>> charge_density('KTT_pNGD') 0.0 >>> charge_density('FPAL', pH=13) -0.25 \"\"\" return charge ( peptide , pH ) / molecular_weight ( peptide )","title":"charge_density()"},{"location":"api/descriptors/#peptidy.descriptors.compute_descriptors","text":"Computes multiple descriptors of the peptide. Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required descriptor_names List [ str ], optional A List of descriptor names. If any of the descriptor names is invalid, ValueError is raised. Set to None by default, and computes all descriptors in this case. None pH float , optional pH value to compute charge and charge density (if requested), by default 7 7 Returns: Type Description Dict [ str , Union [ float , int ]] A dictionary that maps descriptor names to their values. Raises: Type Description ValueError ValueError is raised if any of the descriptor names is invalid. Examples: >>> compute_descriptors ( 'ACD' , [ 'charge' , 'charge_density' ], 13 ) {'charge': -3.0, 'charge_density': -1.0} >>> test_output == compute_descriptors ( 'STY' , [ 'molecular_formula' ]) >>> expected_output == { 'n_C' : 16 , 'n_H' : 23 , 'n_N' : 3 , 'n_O' : 7 , 'n_S' : 0 , 'n_P' : 0 } >>> for k , v in test_output . items (): ... assert v == expected_output [ k ] Source code in peptidy/descriptors.py 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 def compute_descriptors ( peptide : str , descriptor_names : List [ str ] = None , pH : float = 7 , ) -> Dict [ str , Union [ float , int ]]: \"\"\"Computes multiple descriptors of the peptide. Parameters ---------- peptide : str Amino acid sequence of the peptide. descriptor_names : List[str], optional A List of descriptor names. If any of the descriptor names is invalid, ValueError is raised. Set to None by default, and computes all descriptors in this case. pH : float, optional pH value to compute charge and charge density (if requested), by default 7 Returns ---------- Dict[str, Union[float, int]] A dictionary that maps descriptor names to their values. Raises ---------- ValueError ValueError is raised if any of the descriptor names is invalid. Examples ---------- >>> compute_descriptors('ACD', ['charge', 'charge_density'], 13) {'charge': -3.0, 'charge_density': -1.0} >>> test_output==compute_descriptors('STY', ['molecular_formula']) >>> expected_output=={'n_C': 16, 'n_H': 23, 'n_N': 3, 'n_O': 7, 'n_S': 0, 'n_P': 0} >>> for k, v in test_output.items(): ... assert v == expected_output[k] \"\"\" if descriptor_names is None : descriptor_names = list ( __DESCRIPTOR_FNS . keys ()) diff = set ( descriptor_names ) - set ( __DESCRIPTOR_FNS . keys ()) if len ( diff ) > 0 : raise ValueError ( f \"Invalid descriptor names: { diff } . Possible names are: { list ( __DESCRIPTOR_FNS . keys ()) } \" ) name_to_descriptor = dict () for name in descriptor_names : if name in [ \"charge\" , \"charge_density\" ]: name_to_descriptor [ name ] = __DESCRIPTOR_FNS [ name ]( peptide , pH = pH ) elif name in [ \"aminoacid_frequencies\" , \"molecular_formula\" ]: name_to_descriptor = { ** name_to_descriptor , ** __DESCRIPTOR_FNS [ name ]( peptide ), } else : name_to_descriptor [ name ] = __DESCRIPTOR_FNS [ name ]( peptide ) return name_to_descriptor","title":"compute_descriptors()"},{"location":"api/descriptors/#peptidy.descriptors.hydrophobic_aa_ratio","text":"Calculate the total ratio of hydrophobic amino-acids (A, C, C_m, F, I, L, M, and V) in a peptide. ( Nelson & Cox, 2004 ) Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required Returns: Type Description float Total ratio of hydrophobic amino-acids of the peptide. Examples: >>> hydrophobic_aa_ratio ( 'FC_mPR_mS_pA' ) 0.5 >>> hydrophobic_aa_ratio ( 'FPR_mXS_pA' ) Traceback (most recent call last): ... ValueError : Unknown amino acid(s) in peptide: {'X'} Source code in peptidy/descriptors.py 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 def hydrophobic_aa_ratio ( peptide : str ) -> float : \"\"\" Calculate the total ratio of hydrophobic amino-acids (A, C, C_m, F, I, L, M, and V) in a peptide. ([Nelson & Cox, 2004](https://mis.kp.ac.rw/admin/admin_panel/kp_lms/files/digital/Core%20Books/Core%20Books%20In%20Nursing%20%20And%20%20Midwifery/H106_%20Biochemistry_Lehninger%20Principles%20of%20Biochemistry,%20Fourth%20Edition%20-%20David%20L.%20Nelson,%20Michael%20M.%20Cox.pdf)) Parameters ---------- peptide : str Amino acid sequence of the peptide. Returns ------- float Total ratio of hydrophobic amino-acids of the peptide. Examples -------- >>> hydrophobic_aa_ratio('FC_mPR_mS_pA') 0.5 >>> hydrophobic_aa_ratio('FPR_mXS_pA') Traceback (most recent call last): ... ValueError: Unknown amino acid(s) in peptide: {'X'} \"\"\" tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) aa_counts = dict ( Counter ( tokenized_peptide )) return sum ([ aa_counts . get ( aa , 0 ) for aa in biology . hydrophobic_aas ]) / length ( peptide )","title":"hydrophobic_aa_ratio()"},{"location":"api/descriptors/#peptidy.descriptors.instability_index","text":"Calculate the instability index of the peptide. The instability index is based on amino acid compositions and computed by summing the instability coefficient of all dipeptide combinations in the peptide. It is based on the frequency of the dipeptide occurring in stable versus unstable proteins Guruprasad, Reddy & Pandit, 1990 . A value of 1 is used for amino acid pairs whose instability coefficient is unavailable. Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required Returns: Type Description float Examples: >>> # from https://rdrr.io/cran/Peptides/src/R/boman.R >>> instability_index ( 'ACFEGM' ) 81.566... >>> instability_index ( 'FPP_mS_pA' ) Traceback (most recent call last): ... ValueError : Unknown amino acid(s) in peptide: {'P_m'} Source code in peptidy/descriptors.py 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 def instability_index ( peptide : str ) -> float : \"\"\" Calculate the instability index of the peptide. The instability index is based on amino acid compositions and computed by summing the instability coefficient of all dipeptide combinations in the peptide. It is based on the frequency of the dipeptide occurring in stable versus unstable proteins [Guruprasad, Reddy & Pandit, 1990](https://academic.oup.com/peds/article-abstract/4/2/155/1491271). A value of 1 is used for amino acid pairs whose instability coefficient is unavailable. Parameters ---------- peptide : str Amino acid sequence of the peptide. Returns ------- float Examples -------- >>> # from https://rdrr.io/cran/Peptides/src/R/boman.R >>> instability_index('ACFEGM') 81.566... >>> instability_index('FPP_mS_pA') Traceback (most recent call last): ... ValueError: Unknown amino acid(s) in peptide: {'P_m'} \"\"\" tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) aa_pairs = zip ( tokenized_peptide , tokenized_peptide [ 1 :]) instabilities = [ biology . instabilities [ aa1 ][ aa2 ] for aa1 , aa2 in aa_pairs ] return sum ( instabilities ) * 10 / length ( peptide )","title":"instability_index()"},{"location":"api/descriptors/#peptidy.descriptors.isoelectric_point","text":"Calculate the isoelectric point (pH that the peptide carries no net charge) of the peptide. The isoelectric point is calculated using the peptide charge at different pH values. The method used is based on the Henderson-Hasselbach equation Aronson, 1983 . Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required Returns: Type Description float Isoelectric point of the peptide. Examples: >>> isoelectric_point ( 'ADEFGHI' ) 3.92... >>> isoelectric_point ( 'K_aMSTV' ) 3.44... Source code in peptidy/descriptors.py 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 def isoelectric_point ( peptide : str ) -> float : \"\"\" Calculate the isoelectric point (pH that the peptide carries no net charge) of the peptide. The isoelectric point is calculated using the peptide charge at different pH values. The method used is based on the Henderson-Hasselbach equation [Aronson, 1983](https://www.sciencedirect.com/science/article/pii/0307441283900468?via%3Dihub). Parameters ---------- peptide : str Amino acid sequence of the peptide. Returns ------- float Isoelectric point of the peptide. Examples -------- >>> isoelectric_point('ADEFGHI') 3.92... >>> isoelectric_point('K_aMSTV') 3.44... \"\"\" test_ph = 7 peptide_charge = charge ( peptide , test_ph ) if peptide_charge < 0 : lower_limit , upper_limit = 0 , 7 else : lower_limit , upper_limit = 7 , 14 precision = 10 **- 4 while ( upper_limit - lower_limit ) > precision and abs ( peptide_charge ) > precision : test_ph = ( upper_limit + lower_limit ) / 2 peptide_charge = charge ( peptide , test_ph ) if peptide_charge < 0 : upper_limit = test_ph else : lower_limit = test_ph return test_ph","title":"isoelectric_point()"},{"location":"api/descriptors/#peptidy.descriptors.length","text":"Calculate the number of amino acids in the peptide. Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required Returns: Type Description int Number of amino acids in the peptide. Examples: >>> length ( 'ACD' ) 3 >>> length ( 'C_mS_pADDWY' ) 7 >>> length ( 'FP_mS_pA' ) Traceback (most recent call last): ... ValueError : Unknown amino acid(s) in peptide: {'P_m'} Source code in peptidy/descriptors.py 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 def length ( peptide : str ) -> int : \"\"\" Calculate the number of amino acids in the peptide. Parameters ---------- peptide : str Amino acid sequence of the peptide. Returns ------- int Number of amino acids in the peptide. Examples -------- >>> length('ACD') 3 >>> length('C_mS_pADDWY') 7 >>> length('FP_mS_pA') Traceback (most recent call last): ... ValueError: Unknown amino acid(s) in peptide: {'P_m'} \"\"\" return len ( tokenizer . tokenize_peptide ( peptide ))","title":"length()"},{"location":"api/descriptors/#peptidy.descriptors.molecular_formula","text":"Determine the closed molecular formula of the amino acid sequence of the peptide. The peptide bonds between amino acids are included in the formula. Molecular formulas were retrieved from PubChem . Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required Returns: Type Description Dict [ str , int ] Count of each element in the peptide where the element symbols are keys and counts are values. The keys have the format n_<element> ( element = element symbol). Examples: >>> formula = molecular_formula ( 'ADEF' ) >>> formula [ 'n_H' ] 28 >>> formula [ 'n_O' ] 9 >>> formula [ 'n_S' ] 0 >>> formula = molecular_formula ( 'PTHRAAPDES' ) >>> formula [ 'n_H' ] 69 >>> formula [ 'n_O' ] 17 >>> formula [ 'n_S' ] 0 Source code in peptidy/descriptors.py 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 def molecular_formula ( peptide : str , ) -> Dict [ str , int ]: \"\"\" Determine the closed molecular formula of the amino acid sequence of the peptide. The peptide bonds between amino acids are included in the formula. Molecular formulas were retrieved from [PubChem](https://pubchem.ncbi.nlm.nih.gov/). Parameters ---------- peptide : str Amino acid sequence of the peptide. Returns ------- Dict[str, int] Count of each element in the peptide where the element symbols are keys and counts are values. The keys have the format `n_<element>` (`element` = element symbol). Examples -------- >>> formula = molecular_formula('ADEF') >>> formula['n_H'] 28 >>> formula['n_O'] 9 >>> formula['n_S'] 0 >>> formula = molecular_formula('PTHRAAPDES') >>> formula['n_H'] 69 >>> formula['n_O'] 17 >>> formula['n_S'] 0 \"\"\" tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) aa_formulas = [ Counter ( biology . formulas [ aa ]) for aa in tokenized_peptide ] elements = [ \"C\" , \"H\" , \"N\" , \"O\" , \"S\" , \"P\" ] peptide_formula = dict () for element in elements : peptide_formula [ f \"n_ { element } \" ] = sum ( [ formula [ element ] for formula in aa_formulas ] ) peptide_formula [ \"n_H\" ] = peptide_formula [ \"n_H\" ] - 2 * length ( peptide ) + 2 peptide_formula [ \"n_O\" ] = peptide_formula [ \"n_O\" ] - length ( peptide ) + 1 return peptide_formula","title":"molecular_formula()"},{"location":"api/descriptors/#peptidy.descriptors.molecular_weight","text":"Calculate the weight (g/mol) of the peptide without peptide bonds. The molecular weight of the peptide is calculated by summing the weights of the amino acids and subtracting the weight of water for each peptide bond. Molecular weight were retrieved from PubChem . Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required Returns: Type Description float Molecular weight of the peptide. Examples: >>> molecular_weight ( 'RMK_aS_pCD' ) 860.885 >>> molecular_weight ( 'DEGHI' ) 569.56 Source code in peptidy/descriptors.py 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 def molecular_weight ( peptide : str ) -> float : \"\"\" Calculate the weight (g/mol) of the peptide without peptide bonds. The molecular weight of the peptide is calculated by summing the weights of the amino acids and subtracting the weight of water for each peptide bond. Molecular weight were retrieved from [PubChem](https://pubchem.ncbi.nlm.nih.gov/). Parameters ---------- peptide : str Amino acid sequence of the peptide. Returns ------- float Molecular weight of the peptide. Examples -------- >>> molecular_weight('RMK_aS_pCD') 860.885 >>> molecular_weight('DEGHI') 569.56 \"\"\" tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) total_weight = sum ([ biology . weights [ aa ] for aa in tokenized_peptide ]) return total_weight - 18.015 * ( length ( peptide ) - 1 )","title":"molecular_weight()"},{"location":"api/descriptors/#peptidy.descriptors.n_h_acceptors","text":"Calculate the total number of hydrogen bond acceptors in the peptide. The number of hydrogen bond acceptors in the peptide is calculated by summing the number of hydrogen bond acceptors. Hydrogen bonds are important in protein-protein interactions Hubbard & Haider, 2010 . The number of hydrogen bond acceptors for each amino acid were retrieved from PubChem . Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required Returns: Type Description float Total number of hydrogen bond acceptors in the peptide. Examples: >>> n_h_acceptors ( 'FSCA' ) 14 >>> n_h_acceptors ( 'FXS_pGNM' ) Traceback (most recent call last): ... ValueError : Unknown amino acid(s) in peptide: {'X'} Source code in peptidy/descriptors.py 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 def n_h_acceptors ( peptide : str ) -> float : \"\"\" Calculate the total number of hydrogen bond acceptors in the peptide. The number of hydrogen bond acceptors in the peptide is calculated by summing the number of hydrogen bond acceptors. Hydrogen bonds are important in protein-protein interactions [Hubbard & Haider, 2010](https://doi.org/10.1002/9780470015902.a0003011.pub2). The number of hydrogen bond acceptors for each amino acid were retrieved from [PubChem](https://pubchem.ncbi.nlm.nih.gov/). Parameters ---------- peptide : str Amino acid sequence of the peptide. Returns ------- float Total number of hydrogen bond acceptors in the peptide. Examples -------- >>> n_h_acceptors('FSCA') 14 >>> n_h_acceptors('FXS_pGNM') Traceback (most recent call last): ... ValueError: Unknown amino acid(s) in peptide: {'X'} \"\"\" tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) return sum ([ biology . n_h_acceptors [ aa ] for aa in tokenized_peptide ])","title":"n_h_acceptors()"},{"location":"api/descriptors/#peptidy.descriptors.n_h_donors","text":"Calculate the total number of hydrogen bond donors in the peptide. Hydrogen bonds are important in protein-protein interactions Hubbard & Haider, 2010 . The number of hydrogen bond donors for each amino acid were retrieved from PubChem . Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required Returns: Type Description float Total number of hydrogen bond donors in the peptide. Examples: >>> n_h_donors ( 'VYP' ) 7 >>> n_h_donors ( 'PGU' ) Traceback (most recent call last): ... ValueError : Unknown amino acid(s) in peptide: {'U'} Source code in peptidy/descriptors.py 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 def n_h_donors ( peptide : str ) -> float : \"\"\" Calculate the total number of hydrogen bond donors in the peptide. Hydrogen bonds are important in protein-protein interactions [Hubbard & Haider, 2010](https://doi.org/10.1002/9780470015902.a0003011.pub2). The number of hydrogen bond donors for each amino acid were retrieved from [PubChem](https://pubchem.ncbi.nlm.nih.gov/). Parameters ---------- peptide : str Amino acid sequence of the peptide. Returns ------- float Total number of hydrogen bond donors in the peptide. Examples -------- >>> n_h_donors('VYP') 7 >>> n_h_donors('PGU') Traceback (most recent call last): ... ValueError: Unknown amino acid(s) in peptide: {'U'} \"\"\" tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) return sum ([ biology . n_h_donors [ aa ] for aa in tokenized_peptide ])","title":"n_h_donors()"},{"location":"api/descriptors/#peptidy.descriptors.topological_polar_surface_area","text":"Calculate the total topological polar surface area of the peptide. The topological polar surface area relates to the Van der Waals forces Adhav & Saikrishnan, 2023 . Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required Returns: Type Description float Total topological polar surface area of the peptide. Examples: >>> topological_polar_surface_area ( 'R_dPSRMNPAWE' ) 853.19... >>> topological_polar_surface_area ( 'AYZ' ) Traceback (most recent call last): ... ValueError : Unknown amino acid(s) in peptide: {'Z'} Source code in peptidy/descriptors.py 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 def topological_polar_surface_area ( peptide : str , ) -> float : \"\"\" Calculate the total topological polar surface area of the peptide. The topological polar surface area relates to the Van der Waals forces [Adhav & Saikrishnan, 2023](https://pubs.acs.org/doi/10.1021/acsomega.3c00205). Parameters ---------- peptide : str Amino acid sequence of the peptide. Returns ---------- float Total topological polar surface area of the peptide. Examples ---------- >>> topological_polar_surface_area('R_dPSRMNPAWE') 853.19... >>> topological_polar_surface_area('AYZ') Traceback (most recent call last): ... ValueError: Unknown amino acid(s) in peptide: {'Z'} \"\"\" tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) total_surface = sum ([ biology . tpsas [ aa ] for aa in tokenized_peptide ]) return total_surface","title":"topological_polar_surface_area()"},{"location":"api/descriptors/#peptidy.descriptors.x_logp_energy","text":"Calculate the sum of xlogP index of the peptide divided by the length of the peptide. The xlogP index is a measure of the hydrophobicity of the peptide Chen et al, 2007 and the indices per amino acid was retrieved from PubChem . Parameters: Name Type Description Default peptide str Amino acid sequence of the peptide. required Returns: Type Description float xlogP index of the peptide. Examples: >>> x_logp_energy ( 'R_dPSRMNPAWE' ) 2.9 >>> x_logp_energy ( 'BCAF' ) Traceback (most recent call last): ... ValueError : Unknown amino acid(s) in peptide: {'B'} Source code in peptidy/descriptors.py 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 def x_logp_energy ( peptide : str ) -> float : \"\"\" Calculate the sum of xlogP index of the peptide divided by the length of the peptide. The xlogP index is a measure of the hydrophobicity of the peptide [Chen et al, 2007](https://pubs.acs.org/doi/10.1021/ci700257y) and the indices per amino acid was retrieved from [PubChem](https://pubchem.ncbi.nlm.nih.gov/). Parameters ---------- peptide : str Amino acid sequence of the peptide. Returns ---------- float xlogP index of the peptide. Examples ---------- >>> x_logp_energy('R_dPSRMNPAWE') 2.9 >>> x_logp_energy('BCAF') Traceback (most recent call last): ... ValueError: Unknown amino acid(s) in peptide: {'B'} \"\"\" tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) energy = sum ([ - biology . x_logps [ aa ] for aa in tokenized_peptide ]) return energy / length ( peptide )","title":"x_logp_energy()"},{"location":"api/encoding/","text":"encoding aminoacid_descriptor_encoding ( peptide , descriptor_names = None , padding_len = None , add_generative_tokens = False , generative_token_value =- 1 , return_dimension_names = False ) Encode a peptide as sequence of vectors where each vector represents physicochemical properties of amino acids. Parameters: Name Type Description Default peptide str The input peptide sequence. required descriptor_names List [ str ], optional The names of the amino acid descriptors to include in the encoding. If None, all available descriptors will be used. Defaults to None. None padding_len int The length to which the encoded vector should be padded. If the vector is shorter than padding_len, it will be padded with generative_token_value. If it is longer, a ValueError will be raised. Defaults to None. None add_generative_tokens bool , optional Whether to add special tokens to the beginning and end ( \"<beg>\" , \"<end>\" ) of the encoded vector for generative applications. If True, the generative_token_value will be used for the special tokens. Defaults to False. False generative_token_value int , optional The value to use for the special tokens and padding. Defaults to -1. -1 return_dimension_names bool , optional Whether to return the list of descriptor names used in the encoding. If True, the function will return a tuple of (vectors, descriptor_names). If False, it will only return the encoded vectors. Defaults to False. False Returns: Type Description Union [ List [ List [ int ]], Tuple [ List [ List [ int ]], List [ str ]]] The encoded vectors representing the peptide sequence. If return_dimension_names is True, a tuple of (vectors, descriptor_names) will be returned. Raises: Type Description ValueError: If padding_len is less than the length of the encoded vector. Examples: >>> aminoacid_descriptor_encoding ( 'ACD' , descriptor_names = [ 'molecular_weight' , 'average_number_rotatable_bonds' ]) [[89.09, 1.0], [121.16, 2.0], [133.1, 3.0]] >>> aminoacid_descriptor_encoding ( 'ACD' , descriptor_names = [ 'molecular_weight' , 'average_number_rotatable_bonds' ], padding_len = 6 ) [[89.09, 1.0], [121.16, 2.0], [133.1, 3.0], [-1, -1], [-1, -1], [-1, -1]] >>> aminoacid_descriptor_encoding ( 'ACD' , descriptor_names = [ 'molecular_weight' , 'average_number_rotatable_bonds' ], padding_len = 6 , add_generative_tokens = True ) [[-1, -1], [89.09, 1.0], [121.16, 2.0], [133.1, 3.0], [-1, -1], [-1, -1]] >>> aminoacid_descriptor_encoding ( 'ACD' , descriptor_names = [ 'molecular_formula' ], return_dimension_names = True ) ([[3, 7, 1, 2, 0, 0], [3, 7, 1, 2, 1, 0], [4, 7, 1, 4, 0, 0]], ['n_C', 'n_H', 'n_N', 'n_O', 'n_S', 'n_P']) >>> aminoacid_descriptor_encoding ( 'R_mKGFS_p' , descriptor_names = [ 'charge' ], padding_len = 2 , add_generative_tokens = False , generative_token_value =- 1 , return_dimension_names = False ) Traceback (most recent call last): ... ValueError : Padding length must be greater than or equal to input length Source code in peptidy/encoding.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def aminoacid_descriptor_encoding ( peptide : str , descriptor_names : List [ str ] = None , padding_len : int = None , add_generative_tokens : bool = False , generative_token_value : int = - 1 , return_dimension_names : bool = False , ) -> Union [ List [ List [ int ]], Tuple [ List [ List [ int ]], List [ str ]]]: \"\"\" Encode a peptide as sequence of vectors where each vector represents physicochemical properties of amino acids. Parameters ---------- peptide : str The input peptide sequence. descriptor_names : List[str], optional The names of the amino acid descriptors to include in the encoding. If None, all available descriptors will be used. Defaults to None. padding_len :int, optional The length to which the encoded vector should be padded. If the vector is shorter than padding_len, it will be padded with generative_token_value. If it is longer, a ValueError will be raised. Defaults to None. add_generative_tokens : bool, optional Whether to add special tokens to the beginning and end (`\"<beg>\"`,`\"<end>\"`) of the encoded vector for generative applications. If True, the `generative_token_value` will be used for the special tokens. Defaults to False. generative_token_value : int, optional The value to use for the special tokens and padding. Defaults to -1. return_dimension_names : bool, optional Whether to return the list of descriptor names used in the encoding. If True, the function will return a tuple of (vectors, descriptor_names). If False, it will only return the encoded vectors. Defaults to False. Returns ------- Union[List[List[int]], Tuple[List[List[int]], List[str]]]: The encoded vectors representing the peptide sequence. If return_dimension_names is True, a tuple of (vectors, descriptor_names) will be returned. Raises ------ ValueError: If padding_len is less than the length of the encoded vector. Examples -------- >>> aminoacid_descriptor_encoding('ACD', descriptor_names=['molecular_weight', 'average_number_rotatable_bonds']) [[89.09, 1.0], [121.16, 2.0], [133.1, 3.0]] >>> aminoacid_descriptor_encoding('ACD', descriptor_names=['molecular_weight', 'average_number_rotatable_bonds'], padding_len=6) # doctest: +NORMALIZE_WHITESPACE [[89.09, 1.0], [121.16, 2.0], [133.1, 3.0], [-1, -1], [-1, -1], [-1, -1]] >>> aminoacid_descriptor_encoding('ACD', descriptor_names=['molecular_weight', 'average_number_rotatable_bonds'], padding_len=6, add_generative_tokens=True) # doctest: +NORMALIZE_WHITESPACE [[-1, -1], [89.09, 1.0], [121.16, 2.0], [133.1, 3.0], [-1, -1], [-1, -1]] >>> aminoacid_descriptor_encoding('ACD', descriptor_names=['molecular_formula'], return_dimension_names=True) # doctest: +NORMALIZE_WHITESPACE ([[3, 7, 1, 2, 0, 0], [3, 7, 1, 2, 1, 0], [4, 7, 1, 4, 0, 0]], ['n_C', 'n_H', 'n_N', 'n_O', 'n_S', 'n_P']) >>> aminoacid_descriptor_encoding('R_mKGFS_p', descriptor_names=['charge'], padding_len=2, add_generative_tokens=False, generative_token_value=-1, return_dimension_names=False) Traceback (most recent call last): ... ValueError: Padding length must be greater than or equal to input length \"\"\" aa_descriptors = biology . descriptor_per_aas if descriptor_names is None : descriptor_names = list ( aa_descriptors [ \"A\" ] . keys ()) if \"molecular_formula\" in descriptor_names : # replace molecular_formula with n_C, n_H, n_N, n_O, n_S, n_P descriptor_names . remove ( \"molecular_formula\" ) descriptor_names . extend ([ \"n_C\" , \"n_H\" , \"n_N\" , \"n_O\" , \"n_S\" , \"n_P\" ]) tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) vector_len = len ( descriptor_names ) vectors = list () if add_generative_tokens : vectors . append ( vector_len * [ generative_token_value ]) # add beginning token vectors = vectors + [ [ aa_descriptors [ token ][ descriptor ] for descriptor in descriptor_names ] for token in tokenized_peptide ] if add_generative_tokens : vectors . append ( vector_len * [ generative_token_value ]) # add end token if padding_len is not None : if padding_len < len ( vectors ): raise ValueError ( \"Padding length must be greater than or equal to input length\" ) padding_vector = [ generative_token_value ] * vector_len n_padding = padding_len - len ( vectors ) for _ in range ( n_padding ): vectors . append ( padding_vector . copy ()) if return_dimension_names : return vectors , descriptor_names return vectors blosum62_encoding ( peptide , encode_post_translation = True , padding_len = None , add_generative_tokens = False , generative_token_value = 0 , return_dimension_names = False ) Encodes a peptide sequence using BLOSUM62 encoding. Parameters: Name Type Description Default peptide str The peptide sequence to be encoded. required encode_post_translation bool , optional Whether to encode post-translation information. Defaults to True. True padding_len int , optional The length to which the encoded vectors should be padded. Defaults to None. None add_generative_tokens bool , optional Whether to add special tokens to the encoded vectors. Defaults to False. False generative_token_value int , optional The value to be used for the special tokens. Defaults to 0 to assume no (dis)similarity. 0 return_dimension_names bool , optional Whether to return the names of the dimensions of the BLOSUM encodings. Defaults to False. False Returns: Type Description Union [ List [ List [ int ]], Tuple [ List [ List [ int ]], List [ str ]]] The BLOSUM vectors representing the peptide sequence. The dimension names will also be returned if return_dimension_names is True. Raises: Type Description ValueError: If the padding length is less than the input length. Examples: >>> blosum62_encoding ( 'A' ) [[4, 0, -2, -1, -2, 0, -2, -1, -1, -1, -1, -2, -1, -1, -1, 1, 0, 0, -3, -2, 0]] >>> blosum62_encoding ( 'A' , encode_post_translation = False ) [[4, 0, -2, -1, -2, 0, -2, -1, -1, -1, -1, -2, -1, -1, -1, 1, 0, 0, -3, -2]] >>> blosum62_encoding ( 'ACD' ) [[4, 0, -2, -1, -2, 0, -2, -1, -1, -1, -1, -2, -1, -1, -1, 1, 0, 0, -3, -2, 0], [0, 9, -3, -4, -2, -3, -3, -1, -3, -1, -1, -3, -3, -3, -3, -1, -1, -1, -2, -2, 0], [-2, -3, 6, 2, -3, -1, -1, -3, -1, -4, -3, 1, -1, 0, -2, 0, -1, -3, -4, -3, 0]] >>> blosum62_encoding ( 'ACDK_a' , return_dimension_names = True ) ([[4, 0, -2, -1, -2, 0, -2, -1, -1, -1, -1, -2, -1, -1, -1, 1, 0, 0, -3, -2, 0], [0, 9, -3, -4, -2, -3, -3, -1, -3, -1, -1, -3, -3, -3, -3, -1, -1, -1, -2, -2, 0], [-2, -3, 6, 2, -3, -1, -1, -3, -1, -4, -3, 1, -1, 0, -2, 0, -1, -3, -4, -3, 0], [-1, -3, -1, 1, -3, -2, -1, -3, 5, -2, -1, 0, -1, 1, 2, 0, -1, -2, -3, -2, 1]], ['A', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'Y', 'is_post_translated']) >>> blosum62_encoding ( 'ACDK_a' , padding_len = 7 , add_generative_tokens = True ) [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 0, -2, -1, -2, 0, -2, -1, -1, -1, -1, -2, -1, -1, -1, 1, 0, 0, -3, -2, 0], [0, 9, -3, -4, -2, -3, -3, -1, -3, -1, -1, -3, -3, -3, -3, -1, -1, -1, -2, -2, 0], [-2, -3, 6, 2, -3, -1, -1, -3, -1, -4, -3, 1, -1, 0, -2, 0, -1, -3, -4, -3, 0], [-1, -3, -1, 1, -3, -2, -1, -3, 5, -2, -1, 0, -1, 1, 2, 0, -1, -2, -3, -2, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]] Source code in peptidy/encoding.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def blosum62_encoding ( peptide : str , encode_post_translation : bool = True , padding_len : int = None , add_generative_tokens : bool = False , generative_token_value : int = 0 , return_dimension_names : bool = False , ) -> Union [ List [ List [ int ]], Tuple [ List [ List [ int ]], List [ str ]]]: \"\"\" Encodes a peptide sequence using BLOSUM62 encoding. Parameters ---------- peptide : str The peptide sequence to be encoded. encode_post_translation : bool, optional Whether to encode post-translation information. Defaults to True. padding_len : int, optional The length to which the encoded vectors should be padded. Defaults to None. add_generative_tokens : bool, optional Whether to add special tokens to the encoded vectors. Defaults to False. generative_token_value : int, optional The value to be used for the special tokens. Defaults to 0 to assume no (dis)similarity. return_dimension_names : bool, optional Whether to return the names of the dimensions of the BLOSUM encodings. Defaults to False. Returns ------- Union[List[List[int]], Tuple[List[List[int]], List[str]]]: The BLOSUM vectors representing the peptide sequence. The dimension names will also be returned if return_dimension_names is True. Raises ------ ValueError: If the padding length is less than the input length. Examples -------- >>> blosum62_encoding('A') # doctest: +NORMALIZE_WHITESPACE [[4, 0, -2, -1, -2, 0, -2, -1, -1, -1, -1, -2, -1, -1, -1, 1, 0, 0, -3, -2, 0]] >>> blosum62_encoding('A', encode_post_translation=False) # doctest: +NORMALIZE_WHITESPACE [[4, 0, -2, -1, -2, 0, -2, -1, -1, -1, -1, -2, -1, -1, -1, 1, 0, 0, -3, -2]] >>> blosum62_encoding('ACD') # doctest: +NORMALIZE_WHITESPACE [[4, 0, -2, -1, -2, 0, -2, -1, -1, -1, -1, -2, -1, -1, -1, 1, 0, 0, -3, -2, 0], [0, 9, -3, -4, -2, -3, -3, -1, -3, -1, -1, -3, -3, -3, -3, -1, -1, -1, -2, -2, 0], [-2, -3, 6, 2, -3, -1, -1, -3, -1, -4, -3, 1, -1, 0, -2, 0, -1, -3, -4, -3, 0]] >>> blosum62_encoding('ACDK_a', return_dimension_names=True) # doctest: +NORMALIZE_WHITESPACE ([[4, 0, -2, -1, -2, 0, -2, -1, -1, -1, -1, -2, -1, -1, -1, 1, 0, 0, -3, -2, 0], [0, 9, -3, -4, -2, -3, -3, -1, -3, -1, -1, -3, -3, -3, -3, -1, -1, -1, -2, -2, 0], [-2, -3, 6, 2, -3, -1, -1, -3, -1, -4, -3, 1, -1, 0, -2, 0, -1, -3, -4, -3, 0], [-1, -3, -1, 1, -3, -2, -1, -3, 5, -2, -1, 0, -1, 1, 2, 0, -1, -2, -3, -2, 1]], ['A', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'Y', 'is_post_translated']) >>> blosum62_encoding('ACDK_a', padding_len=7, add_generative_tokens=True) # doctest: +NORMALIZE_WHITESPACE [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 0, -2, -1, -2, 0, -2, -1, -1, -1, -1, -2, -1, -1, -1, 1, 0, 0, -3, -2, 0], [0, 9, -3, -4, -2, -3, -3, -1, -3, -1, -1, -3, -3, -3, -3, -1, -1, -1, -2, -2, 0], [-2, -3, 6, 2, -3, -1, -1, -3, -1, -4, -3, 1, -1, 0, -2, 0, -1, -3, -4, -3, 0], [-1, -3, -1, 1, -3, -2, -1, -3, 5, -2, -1, 0, -1, 1, 2, 0, -1, -2, -3, -2, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]] \"\"\" blosum62 = copy . deepcopy ( biology . blosum62_scores ) tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) vector_len = len ( blosum62 [ \"A\" ]) + int ( encode_post_translation ) vectors = list () if add_generative_tokens : vectors . append ( vector_len * [ generative_token_value ]) # add beginning token for token in tokenized_peptide : aa = token [ 0 ] aa_vector = blosum62 [ aa ] . copy () if encode_post_translation : is_post_translated = len ( token ) > 1 aa_vector . append ( int ( is_post_translated )) vectors . append ( aa_vector ) if add_generative_tokens : vectors . append ( vector_len * [ generative_token_value ]) # add end token if padding_len is not None : if padding_len < len ( vectors ): raise ValueError ( \"Padding length must be greater than or equal to input length\" ) padding_vector = [ generative_token_value ] * vector_len n_padding = padding_len - len ( vectors ) for _ in range ( n_padding ): vectors . append ( padding_vector . copy ()) if return_dimension_names : aa_names = list ( blosum62 . keys ()) if encode_post_translation : aa_names . append ( \"is_post_translated\" ) return vectors , aa_names return vectors label_encoding ( peptide , padding_len = None , add_generative_tokens = False ) Encodes a peptide sequence using label encoding. Parameters: Name Type Description Default peptide str The input peptide sequence to be encoded. required padding_len int , optional The length to which the encoded sequence should be padded. Defaults to None. None add_generative_tokens bool , optional Whether to add special tokens at the beginning and end of the encoded sequence. Defaults to False. False Returns: Type Description List [ int ] The encoded peptide sequence as a list of integers. Raises: Type Description ValueError If the padding length is less than the input length. Examples: >>> label_encoding ( 'ACD' ) [1, 2, 3] >>> label_encoding ( 'ACDK_a' , padding_len = 7 ) [1, 2, 3, 28, 0, 0, 0] >>> label_encoding ( 'ACD' , padding_len = 7 , add_generative_tokens = True ) [29, 1, 2, 3, 30, 0, 0] >>> label_encoding ( 'AXR' ) Traceback (most recent call last): ... ValueError : Unknown amino acid(s) in peptide: {'X'} >>> label_encoding ( 'A_C_D' ) Traceback (most recent call last): ... ValueError : Unknown amino acid(s) in peptide: {'A_C_D'} Source code in peptidy/encoding.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 def label_encoding ( peptide : str , padding_len : int = None , add_generative_tokens : bool = False , ) -> List [ int ]: \"\"\" Encodes a peptide sequence using label encoding. Parameters ---------- peptide : str The input peptide sequence to be encoded. padding_len : int, optional The length to which the encoded sequence should be padded. Defaults to None. add_generative_tokens : bool, optional Whether to add special tokens at the beginning and end of the encoded sequence. Defaults to False. Returns ------- List[int] The encoded peptide sequence as a list of integers. Raises ------ ValueError If the padding length is less than the input length. Examples -------- >>> label_encoding('ACD') [1, 2, 3] >>> label_encoding('ACDK_a', padding_len=7) # doctest: +NORMALIZE_WHITESPACE [1, 2, 3, 28, 0, 0, 0] >>> label_encoding('ACD', padding_len=7, add_generative_tokens=True) [29, 1, 2, 3, 30, 0, 0] >>> label_encoding('AXR') Traceback (most recent call last): ... ValueError: Unknown amino acid(s) in peptide: {'X'} >>> label_encoding('A_C_D') Traceback (most recent call last): ... ValueError: Unknown amino acid(s) in peptide: {'A_C_D'} \"\"\" token_to_label = biology . token_to_label . copy () labels = list () if add_generative_tokens : labels . append ( len ( token_to_label ) + 1 ) # add beginning token tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) for token in tokenized_peptide : labels . append ( token_to_label [ token ]) if add_generative_tokens : labels . append ( len ( token_to_label ) + 2 ) # add end token if padding_len is not None : if padding_len < len ( labels ): raise ValueError ( \"Padding length must be greater than or equal to input length\" ) labels = labels + [ 0 ] * ( padding_len - len ( labels )) return labels one_hot_encoding ( peptide , padding_len = None , add_generative_tokens = False ) Encodes a peptide sequence using one-hot encoding. Parameters: Name Type Description Default peptide str The input peptide sequence to be encoded. required padding_len int , optional The length to which the encoded sequence should be padded. Defaults to None. None add_generative_tokens bool , optional Whether to add <beg> and <end> tokens at the start and end of the encoded sequence for language modeling applications. Defaults to False. False Returns: Type Description List [ List [ int ]] The encoded peptide sequence represented as a list of one-hot encoded vectors. Raises: Type Description ValueError: If the padding length is less than the input length. Examples: >>> one_hot_encoding ( 'ACD' ) [[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]] >>> one_hot_encoding ( 'ACD' , padding_len = 5 ) [[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]] one_hot_encoding('ACDK_a', padding_len=7, add_generative_tokens=True) # doctest: +NORMALIZE_WHITESPACE [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]] Source code in peptidy/encoding.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 def one_hot_encoding ( peptide : str , padding_len : int = None , add_generative_tokens : bool = False , ) -> List [ List [ int ]]: \"\"\" Encodes a peptide sequence using one-hot encoding. Parameters ---------- peptide : str The input peptide sequence to be encoded. padding_len : int, optional The length to which the encoded sequence should be padded. Defaults to None. add_generative_tokens : bool, optional Whether to add `<beg>` and `<end>` tokens at the start and end of the encoded sequence for language modeling applications. Defaults to False. Returns ------- List[List[int]]: The encoded peptide sequence represented as a list of one-hot encoded vectors. Raises ------ ValueError: If the padding length is less than the input length. Examples -------- >>> one_hot_encoding('ACD') # doctest: +NORMALIZE_WHITESPACE [[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]] >>> one_hot_encoding('ACD', padding_len=5) # doctest: +NORMALIZE_WHITESPACE [[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]] >>> one_hot_encoding('ACDK_a', padding_len=7, add_generative_tokens=True) # doctest: +NORMALIZE_WHITESPACE [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]] \"\"\" token_to_label = biology . token_to_label . copy () vocab_size = len ( token_to_label ) + 1 # Add 1 for padding token vectors = list () if add_generative_tokens : vocab_size = vocab_size + 2 # Add 2 for start and end tokens beg_vector = [ 0 ] * vocab_size beg_vector [ - 2 ] = 1 vectors . append ( beg_vector ) tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) for token in tokenized_peptide : token_vector = [ 0 ] * vocab_size token_vector [ token_to_label [ token ]] = 1 vectors . append ( token_vector ) if add_generative_tokens : end_vector = [ 0 ] * vocab_size end_vector [ - 1 ] = 1 vectors . append ( end_vector ) if padding_len is not None : if padding_len < len ( vectors ): raise ValueError ( \"Padding length must be greater than or equal to input length\" ) pad_vector = [ 0 ] * vocab_size pad_vector [ 0 ] = 1 n_padding = padding_len - len ( vectors ) for _ in range ( n_padding ): vectors . append ( pad_vector . copy ()) return vectors peptide_descriptor_encoding ( peptide , descriptor_names = None , pH = 7.0 , return_dimension_names = False ) Encodes a peptide sequence using amino acid descriptors. Parameters: Name Type Description Default peptide str The input peptide sequence to be encoded. required descriptor_names List [ str ], optional The names of the amino acid descriptors to include in the encoding. Defaults to None and all available descriptors are used. None pH float , optional The pH value to use for charge-based descriptors. Defaults to 7.0. 7.0 return_dimension_names bool , optional Whether to return the list of descriptor names used in the encoding. If True, the function will return a tuple of (descriptors : List[float], descriptor_names: List[str]). If False, it will only return the encoded vectors. Defaults to False. False Returns: Type Description Union [ List [ float ], Tuple [ List [ float ], List [ str ]]] The descriptor vector representing the peptide sequence. If return_dimension_names is True, a tuple of (descriptors : List[float], descriptor_names: List[str]) will be returned. Examples: >>> peptide_descriptor_encoding ( 'ACD' , descriptor_names = [ 'molecular_weight' , 'average_number_rotatable_bonds' ]) [307.32..., 2.0] >>> peptide_descriptor_encoding ( 'AXR' ) Traceback (most recent call last): ... ValueError : Unknown amino acid(s) in peptide: {'X'} Source code in peptidy/encoding.py 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 def peptide_descriptor_encoding ( peptide : str , descriptor_names : List [ str ] = None , pH : float = 7.0 , return_dimension_names : bool = False , ) -> Union [ List [ float ], Tuple [ List [ float ], List [ str ]]]: \"\"\" Encodes a peptide sequence using amino acid descriptors. Parameters ---------- peptide : str The input peptide sequence to be encoded. descriptor_names : List[str], optional The names of the amino acid descriptors to include in the encoding. Defaults to None and all available descriptors are used. pH : float, optional The pH value to use for charge-based descriptors. Defaults to 7.0. return_dimension_names : bool, optional Whether to return the list of descriptor names used in the encoding. If True, the function will return a tuple of (descriptors : List[float], descriptor_names: List[str]). If False, it will only return the encoded vectors. Defaults to False. Returns ------- Union[List[float], Tuple[List[float], List[str]]]: The descriptor vector representing the peptide sequence. If return_dimension_names is True, a tuple of (descriptors : List[float], descriptor_names: List[str]) will be returned. Examples -------- >>> peptide_descriptor_encoding('ACD', descriptor_names=['molecular_weight', 'average_number_rotatable_bonds']) [307.32..., 2.0] >>> peptide_descriptor_encoding('AXR') Traceback (most recent call last): ... ValueError: Unknown amino acid(s) in peptide: {'X'} \"\"\" all_descriptors = descriptors . compute_descriptors ( peptide , descriptor_names , pH ) if return_dimension_names : return list ( all_descriptors . values ()), list ( all_descriptors . keys ()) return list ( all_descriptors . values ())","title":"encoding"},{"location":"api/encoding/#encoding","text":"","title":"encoding"},{"location":"api/encoding/#peptidy.encoding.aminoacid_descriptor_encoding","text":"Encode a peptide as sequence of vectors where each vector represents physicochemical properties of amino acids. Parameters: Name Type Description Default peptide str The input peptide sequence. required descriptor_names List [ str ], optional The names of the amino acid descriptors to include in the encoding. If None, all available descriptors will be used. Defaults to None. None padding_len int The length to which the encoded vector should be padded. If the vector is shorter than padding_len, it will be padded with generative_token_value. If it is longer, a ValueError will be raised. Defaults to None. None add_generative_tokens bool , optional Whether to add special tokens to the beginning and end ( \"<beg>\" , \"<end>\" ) of the encoded vector for generative applications. If True, the generative_token_value will be used for the special tokens. Defaults to False. False generative_token_value int , optional The value to use for the special tokens and padding. Defaults to -1. -1 return_dimension_names bool , optional Whether to return the list of descriptor names used in the encoding. If True, the function will return a tuple of (vectors, descriptor_names). If False, it will only return the encoded vectors. Defaults to False. False Returns: Type Description Union [ List [ List [ int ]], Tuple [ List [ List [ int ]], List [ str ]]] The encoded vectors representing the peptide sequence. If return_dimension_names is True, a tuple of (vectors, descriptor_names) will be returned. Raises: Type Description ValueError: If padding_len is less than the length of the encoded vector. Examples: >>> aminoacid_descriptor_encoding ( 'ACD' , descriptor_names = [ 'molecular_weight' , 'average_number_rotatable_bonds' ]) [[89.09, 1.0], [121.16, 2.0], [133.1, 3.0]] >>> aminoacid_descriptor_encoding ( 'ACD' , descriptor_names = [ 'molecular_weight' , 'average_number_rotatable_bonds' ], padding_len = 6 ) [[89.09, 1.0], [121.16, 2.0], [133.1, 3.0], [-1, -1], [-1, -1], [-1, -1]] >>> aminoacid_descriptor_encoding ( 'ACD' , descriptor_names = [ 'molecular_weight' , 'average_number_rotatable_bonds' ], padding_len = 6 , add_generative_tokens = True ) [[-1, -1], [89.09, 1.0], [121.16, 2.0], [133.1, 3.0], [-1, -1], [-1, -1]] >>> aminoacid_descriptor_encoding ( 'ACD' , descriptor_names = [ 'molecular_formula' ], return_dimension_names = True ) ([[3, 7, 1, 2, 0, 0], [3, 7, 1, 2, 1, 0], [4, 7, 1, 4, 0, 0]], ['n_C', 'n_H', 'n_N', 'n_O', 'n_S', 'n_P']) >>> aminoacid_descriptor_encoding ( 'R_mKGFS_p' , descriptor_names = [ 'charge' ], padding_len = 2 , add_generative_tokens = False , generative_token_value =- 1 , return_dimension_names = False ) Traceback (most recent call last): ... ValueError : Padding length must be greater than or equal to input length Source code in peptidy/encoding.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def aminoacid_descriptor_encoding ( peptide : str , descriptor_names : List [ str ] = None , padding_len : int = None , add_generative_tokens : bool = False , generative_token_value : int = - 1 , return_dimension_names : bool = False , ) -> Union [ List [ List [ int ]], Tuple [ List [ List [ int ]], List [ str ]]]: \"\"\" Encode a peptide as sequence of vectors where each vector represents physicochemical properties of amino acids. Parameters ---------- peptide : str The input peptide sequence. descriptor_names : List[str], optional The names of the amino acid descriptors to include in the encoding. If None, all available descriptors will be used. Defaults to None. padding_len :int, optional The length to which the encoded vector should be padded. If the vector is shorter than padding_len, it will be padded with generative_token_value. If it is longer, a ValueError will be raised. Defaults to None. add_generative_tokens : bool, optional Whether to add special tokens to the beginning and end (`\"<beg>\"`,`\"<end>\"`) of the encoded vector for generative applications. If True, the `generative_token_value` will be used for the special tokens. Defaults to False. generative_token_value : int, optional The value to use for the special tokens and padding. Defaults to -1. return_dimension_names : bool, optional Whether to return the list of descriptor names used in the encoding. If True, the function will return a tuple of (vectors, descriptor_names). If False, it will only return the encoded vectors. Defaults to False. Returns ------- Union[List[List[int]], Tuple[List[List[int]], List[str]]]: The encoded vectors representing the peptide sequence. If return_dimension_names is True, a tuple of (vectors, descriptor_names) will be returned. Raises ------ ValueError: If padding_len is less than the length of the encoded vector. Examples -------- >>> aminoacid_descriptor_encoding('ACD', descriptor_names=['molecular_weight', 'average_number_rotatable_bonds']) [[89.09, 1.0], [121.16, 2.0], [133.1, 3.0]] >>> aminoacid_descriptor_encoding('ACD', descriptor_names=['molecular_weight', 'average_number_rotatable_bonds'], padding_len=6) # doctest: +NORMALIZE_WHITESPACE [[89.09, 1.0], [121.16, 2.0], [133.1, 3.0], [-1, -1], [-1, -1], [-1, -1]] >>> aminoacid_descriptor_encoding('ACD', descriptor_names=['molecular_weight', 'average_number_rotatable_bonds'], padding_len=6, add_generative_tokens=True) # doctest: +NORMALIZE_WHITESPACE [[-1, -1], [89.09, 1.0], [121.16, 2.0], [133.1, 3.0], [-1, -1], [-1, -1]] >>> aminoacid_descriptor_encoding('ACD', descriptor_names=['molecular_formula'], return_dimension_names=True) # doctest: +NORMALIZE_WHITESPACE ([[3, 7, 1, 2, 0, 0], [3, 7, 1, 2, 1, 0], [4, 7, 1, 4, 0, 0]], ['n_C', 'n_H', 'n_N', 'n_O', 'n_S', 'n_P']) >>> aminoacid_descriptor_encoding('R_mKGFS_p', descriptor_names=['charge'], padding_len=2, add_generative_tokens=False, generative_token_value=-1, return_dimension_names=False) Traceback (most recent call last): ... ValueError: Padding length must be greater than or equal to input length \"\"\" aa_descriptors = biology . descriptor_per_aas if descriptor_names is None : descriptor_names = list ( aa_descriptors [ \"A\" ] . keys ()) if \"molecular_formula\" in descriptor_names : # replace molecular_formula with n_C, n_H, n_N, n_O, n_S, n_P descriptor_names . remove ( \"molecular_formula\" ) descriptor_names . extend ([ \"n_C\" , \"n_H\" , \"n_N\" , \"n_O\" , \"n_S\" , \"n_P\" ]) tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) vector_len = len ( descriptor_names ) vectors = list () if add_generative_tokens : vectors . append ( vector_len * [ generative_token_value ]) # add beginning token vectors = vectors + [ [ aa_descriptors [ token ][ descriptor ] for descriptor in descriptor_names ] for token in tokenized_peptide ] if add_generative_tokens : vectors . append ( vector_len * [ generative_token_value ]) # add end token if padding_len is not None : if padding_len < len ( vectors ): raise ValueError ( \"Padding length must be greater than or equal to input length\" ) padding_vector = [ generative_token_value ] * vector_len n_padding = padding_len - len ( vectors ) for _ in range ( n_padding ): vectors . append ( padding_vector . copy ()) if return_dimension_names : return vectors , descriptor_names return vectors","title":"aminoacid_descriptor_encoding()"},{"location":"api/encoding/#peptidy.encoding.blosum62_encoding","text":"Encodes a peptide sequence using BLOSUM62 encoding. Parameters: Name Type Description Default peptide str The peptide sequence to be encoded. required encode_post_translation bool , optional Whether to encode post-translation information. Defaults to True. True padding_len int , optional The length to which the encoded vectors should be padded. Defaults to None. None add_generative_tokens bool , optional Whether to add special tokens to the encoded vectors. Defaults to False. False generative_token_value int , optional The value to be used for the special tokens. Defaults to 0 to assume no (dis)similarity. 0 return_dimension_names bool , optional Whether to return the names of the dimensions of the BLOSUM encodings. Defaults to False. False Returns: Type Description Union [ List [ List [ int ]], Tuple [ List [ List [ int ]], List [ str ]]] The BLOSUM vectors representing the peptide sequence. The dimension names will also be returned if return_dimension_names is True. Raises: Type Description ValueError: If the padding length is less than the input length. Examples: >>> blosum62_encoding ( 'A' ) [[4, 0, -2, -1, -2, 0, -2, -1, -1, -1, -1, -2, -1, -1, -1, 1, 0, 0, -3, -2, 0]] >>> blosum62_encoding ( 'A' , encode_post_translation = False ) [[4, 0, -2, -1, -2, 0, -2, -1, -1, -1, -1, -2, -1, -1, -1, 1, 0, 0, -3, -2]] >>> blosum62_encoding ( 'ACD' ) [[4, 0, -2, -1, -2, 0, -2, -1, -1, -1, -1, -2, -1, -1, -1, 1, 0, 0, -3, -2, 0], [0, 9, -3, -4, -2, -3, -3, -1, -3, -1, -1, -3, -3, -3, -3, -1, -1, -1, -2, -2, 0], [-2, -3, 6, 2, -3, -1, -1, -3, -1, -4, -3, 1, -1, 0, -2, 0, -1, -3, -4, -3, 0]] >>> blosum62_encoding ( 'ACDK_a' , return_dimension_names = True ) ([[4, 0, -2, -1, -2, 0, -2, -1, -1, -1, -1, -2, -1, -1, -1, 1, 0, 0, -3, -2, 0], [0, 9, -3, -4, -2, -3, -3, -1, -3, -1, -1, -3, -3, -3, -3, -1, -1, -1, -2, -2, 0], [-2, -3, 6, 2, -3, -1, -1, -3, -1, -4, -3, 1, -1, 0, -2, 0, -1, -3, -4, -3, 0], [-1, -3, -1, 1, -3, -2, -1, -3, 5, -2, -1, 0, -1, 1, 2, 0, -1, -2, -3, -2, 1]], ['A', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'Y', 'is_post_translated']) >>> blosum62_encoding ( 'ACDK_a' , padding_len = 7 , add_generative_tokens = True ) [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 0, -2, -1, -2, 0, -2, -1, -1, -1, -1, -2, -1, -1, -1, 1, 0, 0, -3, -2, 0], [0, 9, -3, -4, -2, -3, -3, -1, -3, -1, -1, -3, -3, -3, -3, -1, -1, -1, -2, -2, 0], [-2, -3, 6, 2, -3, -1, -1, -3, -1, -4, -3, 1, -1, 0, -2, 0, -1, -3, -4, -3, 0], [-1, -3, -1, 1, -3, -2, -1, -3, 5, -2, -1, 0, -1, 1, 2, 0, -1, -2, -3, -2, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]] Source code in peptidy/encoding.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def blosum62_encoding ( peptide : str , encode_post_translation : bool = True , padding_len : int = None , add_generative_tokens : bool = False , generative_token_value : int = 0 , return_dimension_names : bool = False , ) -> Union [ List [ List [ int ]], Tuple [ List [ List [ int ]], List [ str ]]]: \"\"\" Encodes a peptide sequence using BLOSUM62 encoding. Parameters ---------- peptide : str The peptide sequence to be encoded. encode_post_translation : bool, optional Whether to encode post-translation information. Defaults to True. padding_len : int, optional The length to which the encoded vectors should be padded. Defaults to None. add_generative_tokens : bool, optional Whether to add special tokens to the encoded vectors. Defaults to False. generative_token_value : int, optional The value to be used for the special tokens. Defaults to 0 to assume no (dis)similarity. return_dimension_names : bool, optional Whether to return the names of the dimensions of the BLOSUM encodings. Defaults to False. Returns ------- Union[List[List[int]], Tuple[List[List[int]], List[str]]]: The BLOSUM vectors representing the peptide sequence. The dimension names will also be returned if return_dimension_names is True. Raises ------ ValueError: If the padding length is less than the input length. Examples -------- >>> blosum62_encoding('A') # doctest: +NORMALIZE_WHITESPACE [[4, 0, -2, -1, -2, 0, -2, -1, -1, -1, -1, -2, -1, -1, -1, 1, 0, 0, -3, -2, 0]] >>> blosum62_encoding('A', encode_post_translation=False) # doctest: +NORMALIZE_WHITESPACE [[4, 0, -2, -1, -2, 0, -2, -1, -1, -1, -1, -2, -1, -1, -1, 1, 0, 0, -3, -2]] >>> blosum62_encoding('ACD') # doctest: +NORMALIZE_WHITESPACE [[4, 0, -2, -1, -2, 0, -2, -1, -1, -1, -1, -2, -1, -1, -1, 1, 0, 0, -3, -2, 0], [0, 9, -3, -4, -2, -3, -3, -1, -3, -1, -1, -3, -3, -3, -3, -1, -1, -1, -2, -2, 0], [-2, -3, 6, 2, -3, -1, -1, -3, -1, -4, -3, 1, -1, 0, -2, 0, -1, -3, -4, -3, 0]] >>> blosum62_encoding('ACDK_a', return_dimension_names=True) # doctest: +NORMALIZE_WHITESPACE ([[4, 0, -2, -1, -2, 0, -2, -1, -1, -1, -1, -2, -1, -1, -1, 1, 0, 0, -3, -2, 0], [0, 9, -3, -4, -2, -3, -3, -1, -3, -1, -1, -3, -3, -3, -3, -1, -1, -1, -2, -2, 0], [-2, -3, 6, 2, -3, -1, -1, -3, -1, -4, -3, 1, -1, 0, -2, 0, -1, -3, -4, -3, 0], [-1, -3, -1, 1, -3, -2, -1, -3, 5, -2, -1, 0, -1, 1, 2, 0, -1, -2, -3, -2, 1]], ['A', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'Y', 'is_post_translated']) >>> blosum62_encoding('ACDK_a', padding_len=7, add_generative_tokens=True) # doctest: +NORMALIZE_WHITESPACE [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 0, -2, -1, -2, 0, -2, -1, -1, -1, -1, -2, -1, -1, -1, 1, 0, 0, -3, -2, 0], [0, 9, -3, -4, -2, -3, -3, -1, -3, -1, -1, -3, -3, -3, -3, -1, -1, -1, -2, -2, 0], [-2, -3, 6, 2, -3, -1, -1, -3, -1, -4, -3, 1, -1, 0, -2, 0, -1, -3, -4, -3, 0], [-1, -3, -1, 1, -3, -2, -1, -3, 5, -2, -1, 0, -1, 1, 2, 0, -1, -2, -3, -2, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]] \"\"\" blosum62 = copy . deepcopy ( biology . blosum62_scores ) tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) vector_len = len ( blosum62 [ \"A\" ]) + int ( encode_post_translation ) vectors = list () if add_generative_tokens : vectors . append ( vector_len * [ generative_token_value ]) # add beginning token for token in tokenized_peptide : aa = token [ 0 ] aa_vector = blosum62 [ aa ] . copy () if encode_post_translation : is_post_translated = len ( token ) > 1 aa_vector . append ( int ( is_post_translated )) vectors . append ( aa_vector ) if add_generative_tokens : vectors . append ( vector_len * [ generative_token_value ]) # add end token if padding_len is not None : if padding_len < len ( vectors ): raise ValueError ( \"Padding length must be greater than or equal to input length\" ) padding_vector = [ generative_token_value ] * vector_len n_padding = padding_len - len ( vectors ) for _ in range ( n_padding ): vectors . append ( padding_vector . copy ()) if return_dimension_names : aa_names = list ( blosum62 . keys ()) if encode_post_translation : aa_names . append ( \"is_post_translated\" ) return vectors , aa_names return vectors","title":"blosum62_encoding()"},{"location":"api/encoding/#peptidy.encoding.label_encoding","text":"Encodes a peptide sequence using label encoding. Parameters: Name Type Description Default peptide str The input peptide sequence to be encoded. required padding_len int , optional The length to which the encoded sequence should be padded. Defaults to None. None add_generative_tokens bool , optional Whether to add special tokens at the beginning and end of the encoded sequence. Defaults to False. False Returns: Type Description List [ int ] The encoded peptide sequence as a list of integers. Raises: Type Description ValueError If the padding length is less than the input length. Examples: >>> label_encoding ( 'ACD' ) [1, 2, 3] >>> label_encoding ( 'ACDK_a' , padding_len = 7 ) [1, 2, 3, 28, 0, 0, 0] >>> label_encoding ( 'ACD' , padding_len = 7 , add_generative_tokens = True ) [29, 1, 2, 3, 30, 0, 0] >>> label_encoding ( 'AXR' ) Traceback (most recent call last): ... ValueError : Unknown amino acid(s) in peptide: {'X'} >>> label_encoding ( 'A_C_D' ) Traceback (most recent call last): ... ValueError : Unknown amino acid(s) in peptide: {'A_C_D'} Source code in peptidy/encoding.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 def label_encoding ( peptide : str , padding_len : int = None , add_generative_tokens : bool = False , ) -> List [ int ]: \"\"\" Encodes a peptide sequence using label encoding. Parameters ---------- peptide : str The input peptide sequence to be encoded. padding_len : int, optional The length to which the encoded sequence should be padded. Defaults to None. add_generative_tokens : bool, optional Whether to add special tokens at the beginning and end of the encoded sequence. Defaults to False. Returns ------- List[int] The encoded peptide sequence as a list of integers. Raises ------ ValueError If the padding length is less than the input length. Examples -------- >>> label_encoding('ACD') [1, 2, 3] >>> label_encoding('ACDK_a', padding_len=7) # doctest: +NORMALIZE_WHITESPACE [1, 2, 3, 28, 0, 0, 0] >>> label_encoding('ACD', padding_len=7, add_generative_tokens=True) [29, 1, 2, 3, 30, 0, 0] >>> label_encoding('AXR') Traceback (most recent call last): ... ValueError: Unknown amino acid(s) in peptide: {'X'} >>> label_encoding('A_C_D') Traceback (most recent call last): ... ValueError: Unknown amino acid(s) in peptide: {'A_C_D'} \"\"\" token_to_label = biology . token_to_label . copy () labels = list () if add_generative_tokens : labels . append ( len ( token_to_label ) + 1 ) # add beginning token tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) for token in tokenized_peptide : labels . append ( token_to_label [ token ]) if add_generative_tokens : labels . append ( len ( token_to_label ) + 2 ) # add end token if padding_len is not None : if padding_len < len ( labels ): raise ValueError ( \"Padding length must be greater than or equal to input length\" ) labels = labels + [ 0 ] * ( padding_len - len ( labels )) return labels","title":"label_encoding()"},{"location":"api/encoding/#peptidy.encoding.one_hot_encoding","text":"Encodes a peptide sequence using one-hot encoding. Parameters: Name Type Description Default peptide str The input peptide sequence to be encoded. required padding_len int , optional The length to which the encoded sequence should be padded. Defaults to None. None add_generative_tokens bool , optional Whether to add <beg> and <end> tokens at the start and end of the encoded sequence for language modeling applications. Defaults to False. False Returns: Type Description List [ List [ int ]] The encoded peptide sequence represented as a list of one-hot encoded vectors. Raises: Type Description ValueError: If the padding length is less than the input length. Examples: >>> one_hot_encoding ( 'ACD' ) [[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]] >>> one_hot_encoding ( 'ACD' , padding_len = 5 ) [[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]] one_hot_encoding('ACDK_a', padding_len=7, add_generative_tokens=True) # doctest: +NORMALIZE_WHITESPACE [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]] Source code in peptidy/encoding.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 def one_hot_encoding ( peptide : str , padding_len : int = None , add_generative_tokens : bool = False , ) -> List [ List [ int ]]: \"\"\" Encodes a peptide sequence using one-hot encoding. Parameters ---------- peptide : str The input peptide sequence to be encoded. padding_len : int, optional The length to which the encoded sequence should be padded. Defaults to None. add_generative_tokens : bool, optional Whether to add `<beg>` and `<end>` tokens at the start and end of the encoded sequence for language modeling applications. Defaults to False. Returns ------- List[List[int]]: The encoded peptide sequence represented as a list of one-hot encoded vectors. Raises ------ ValueError: If the padding length is less than the input length. Examples -------- >>> one_hot_encoding('ACD') # doctest: +NORMALIZE_WHITESPACE [[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]] >>> one_hot_encoding('ACD', padding_len=5) # doctest: +NORMALIZE_WHITESPACE [[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]] >>> one_hot_encoding('ACDK_a', padding_len=7, add_generative_tokens=True) # doctest: +NORMALIZE_WHITESPACE [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]] \"\"\" token_to_label = biology . token_to_label . copy () vocab_size = len ( token_to_label ) + 1 # Add 1 for padding token vectors = list () if add_generative_tokens : vocab_size = vocab_size + 2 # Add 2 for start and end tokens beg_vector = [ 0 ] * vocab_size beg_vector [ - 2 ] = 1 vectors . append ( beg_vector ) tokenized_peptide = tokenizer . tokenize_peptide ( peptide ) for token in tokenized_peptide : token_vector = [ 0 ] * vocab_size token_vector [ token_to_label [ token ]] = 1 vectors . append ( token_vector ) if add_generative_tokens : end_vector = [ 0 ] * vocab_size end_vector [ - 1 ] = 1 vectors . append ( end_vector ) if padding_len is not None : if padding_len < len ( vectors ): raise ValueError ( \"Padding length must be greater than or equal to input length\" ) pad_vector = [ 0 ] * vocab_size pad_vector [ 0 ] = 1 n_padding = padding_len - len ( vectors ) for _ in range ( n_padding ): vectors . append ( pad_vector . copy ()) return vectors","title":"one_hot_encoding()"},{"location":"api/encoding/#peptidy.encoding.peptide_descriptor_encoding","text":"Encodes a peptide sequence using amino acid descriptors. Parameters: Name Type Description Default peptide str The input peptide sequence to be encoded. required descriptor_names List [ str ], optional The names of the amino acid descriptors to include in the encoding. Defaults to None and all available descriptors are used. None pH float , optional The pH value to use for charge-based descriptors. Defaults to 7.0. 7.0 return_dimension_names bool , optional Whether to return the list of descriptor names used in the encoding. If True, the function will return a tuple of (descriptors : List[float], descriptor_names: List[str]). If False, it will only return the encoded vectors. Defaults to False. False Returns: Type Description Union [ List [ float ], Tuple [ List [ float ], List [ str ]]] The descriptor vector representing the peptide sequence. If return_dimension_names is True, a tuple of (descriptors : List[float], descriptor_names: List[str]) will be returned. Examples: >>> peptide_descriptor_encoding ( 'ACD' , descriptor_names = [ 'molecular_weight' , 'average_number_rotatable_bonds' ]) [307.32..., 2.0] >>> peptide_descriptor_encoding ( 'AXR' ) Traceback (most recent call last): ... ValueError : Unknown amino acid(s) in peptide: {'X'} Source code in peptidy/encoding.py 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 def peptide_descriptor_encoding ( peptide : str , descriptor_names : List [ str ] = None , pH : float = 7.0 , return_dimension_names : bool = False , ) -> Union [ List [ float ], Tuple [ List [ float ], List [ str ]]]: \"\"\" Encodes a peptide sequence using amino acid descriptors. Parameters ---------- peptide : str The input peptide sequence to be encoded. descriptor_names : List[str], optional The names of the amino acid descriptors to include in the encoding. Defaults to None and all available descriptors are used. pH : float, optional The pH value to use for charge-based descriptors. Defaults to 7.0. return_dimension_names : bool, optional Whether to return the list of descriptor names used in the encoding. If True, the function will return a tuple of (descriptors : List[float], descriptor_names: List[str]). If False, it will only return the encoded vectors. Defaults to False. Returns ------- Union[List[float], Tuple[List[float], List[str]]]: The descriptor vector representing the peptide sequence. If return_dimension_names is True, a tuple of (descriptors : List[float], descriptor_names: List[str]) will be returned. Examples -------- >>> peptide_descriptor_encoding('ACD', descriptor_names=['molecular_weight', 'average_number_rotatable_bonds']) [307.32..., 2.0] >>> peptide_descriptor_encoding('AXR') Traceback (most recent call last): ... ValueError: Unknown amino acid(s) in peptide: {'X'} \"\"\" all_descriptors = descriptors . compute_descriptors ( peptide , descriptor_names , pH ) if return_dimension_names : return list ( all_descriptors . values ()), list ( all_descriptors . keys ()) return list ( all_descriptors . values ())","title":"peptide_descriptor_encoding()"},{"location":"api/tokenizer/","text":"tokenizer tokenize_peptide ( peptide ) Tokenize a peptide sequence into its constituent amino acids. The amino acids are represented by their upper-case one-letter codes. Post-translational modifications are also supported, and are represented as \"<aa>_<mod>\" where <aa> is the amino acid and <mod> is the modification. The list supported amino acids and modifications can be found in the peptidy.biology module. Parameters: Name Type Description Default peptide str A peptide sequence. required Returns: Type Description List [ str ] A list of tokens, each representing an amino acid (possibly with a post-translational modification) in the peptide sequence. Raises: Type Description ValueError If the peptide sequence contains unknown amino acids or a syntax error. Examples: >>> tokenize_peptide ( \"ACDEF\" ) ['A', 'C', 'D', 'E', 'F'] >>> tokenize_peptide ( \"ACK_aDGH\" ) ['A', 'C', 'K_a', 'D', 'G', 'H'] >>> tokenize_peptide ( \"S_pT_p\" ) ['S_p', 'T_p'] >>> tokenize_peptide ( 'ACD' ) ['A', 'C', 'D'] >>> tokenize_peptide ( 'R_mRGD' ) ['R_m', 'R', 'G', 'D'] >>> tokenize_peptide ( 'AXR' ) Traceback (most recent call last): ... ValueError : Unknown amino acid(s) in peptide: {'X'} >>> tokenize_peptide ( 'A_C_D' ) Traceback (most recent call last): ... ValueError : Unknown amino acid(s) in peptide: {'A_C_D'} Source code in peptidy/tokenizer.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def tokenize_peptide ( peptide : str ) -> List [ str ]: \"\"\" Tokenize a peptide sequence into its constituent amino acids. The amino acids are represented by their upper-case one-letter codes. Post-translational modifications are also supported, and are represented as `\"<aa>_<mod>\"` where `<aa>` is the amino acid and `<mod>` is the modification. The list supported amino acids and modifications can be found in the `peptidy.biology` module. Parameters ---------- peptide : str A peptide sequence. Returns ------- List[str] A list of tokens, each representing an amino acid (possibly with a post-translational modification) in the peptide sequence. Raises ------ ValueError If the peptide sequence contains unknown amino acids or a syntax error. Examples -------- >>> tokenize_peptide(\"ACDEF\") ['A', 'C', 'D', 'E', 'F'] >>> tokenize_peptide(\"ACK_aDGH\") ['A', 'C', 'K_a', 'D', 'G', 'H'] >>> tokenize_peptide(\"S_pT_p\") ['S_p', 'T_p'] >>> tokenize_peptide('ACD') ['A', 'C', 'D'] >>> tokenize_peptide('R_mRGD') ['R_m', 'R', 'G', 'D'] >>> tokenize_peptide('AXR') Traceback (most recent call last): ... ValueError: Unknown amino acid(s) in peptide: {'X'} >>> tokenize_peptide('A_C_D') Traceback (most recent call last): ... ValueError: Unknown amino acid(s) in peptide: {'A_C_D'} \"\"\" if \"_\" not in peptide : tokens = list ( peptide ) diff = set ( tokens ) . difference ( __AAs ) if len ( diff ) > 0 : raise ValueError ( \"Unknown amino acid(s) in peptide: \" + str ( diff )) return tokens seq_len = len ( peptide ) tokens = list () char_ix = 0 while char_ix < seq_len : char = peptide [ char_ix ] if char == \"_\" : tokens [ - 1 ] = tokens [ - 1 ] + char + peptide [ char_ix + 1 ] char_ix = char_ix + 2 else : tokens . append ( char ) char_ix = char_ix + 1 diff = set ( tokens ) . difference ( __AAs ) if len ( diff ) > 0 : raise ValueError ( \"Unknown amino acid(s) in peptide: \" + str ( diff )) return tokens","title":"tokenizer"},{"location":"api/tokenizer/#tokenizer","text":"","title":"tokenizer"},{"location":"api/tokenizer/#peptidy.tokenizer.tokenize_peptide","text":"Tokenize a peptide sequence into its constituent amino acids. The amino acids are represented by their upper-case one-letter codes. Post-translational modifications are also supported, and are represented as \"<aa>_<mod>\" where <aa> is the amino acid and <mod> is the modification. The list supported amino acids and modifications can be found in the peptidy.biology module. Parameters: Name Type Description Default peptide str A peptide sequence. required Returns: Type Description List [ str ] A list of tokens, each representing an amino acid (possibly with a post-translational modification) in the peptide sequence. Raises: Type Description ValueError If the peptide sequence contains unknown amino acids or a syntax error. Examples: >>> tokenize_peptide ( \"ACDEF\" ) ['A', 'C', 'D', 'E', 'F'] >>> tokenize_peptide ( \"ACK_aDGH\" ) ['A', 'C', 'K_a', 'D', 'G', 'H'] >>> tokenize_peptide ( \"S_pT_p\" ) ['S_p', 'T_p'] >>> tokenize_peptide ( 'ACD' ) ['A', 'C', 'D'] >>> tokenize_peptide ( 'R_mRGD' ) ['R_m', 'R', 'G', 'D'] >>> tokenize_peptide ( 'AXR' ) Traceback (most recent call last): ... ValueError : Unknown amino acid(s) in peptide: {'X'} >>> tokenize_peptide ( 'A_C_D' ) Traceback (most recent call last): ... ValueError : Unknown amino acid(s) in peptide: {'A_C_D'} Source code in peptidy/tokenizer.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def tokenize_peptide ( peptide : str ) -> List [ str ]: \"\"\" Tokenize a peptide sequence into its constituent amino acids. The amino acids are represented by their upper-case one-letter codes. Post-translational modifications are also supported, and are represented as `\"<aa>_<mod>\"` where `<aa>` is the amino acid and `<mod>` is the modification. The list supported amino acids and modifications can be found in the `peptidy.biology` module. Parameters ---------- peptide : str A peptide sequence. Returns ------- List[str] A list of tokens, each representing an amino acid (possibly with a post-translational modification) in the peptide sequence. Raises ------ ValueError If the peptide sequence contains unknown amino acids or a syntax error. Examples -------- >>> tokenize_peptide(\"ACDEF\") ['A', 'C', 'D', 'E', 'F'] >>> tokenize_peptide(\"ACK_aDGH\") ['A', 'C', 'K_a', 'D', 'G', 'H'] >>> tokenize_peptide(\"S_pT_p\") ['S_p', 'T_p'] >>> tokenize_peptide('ACD') ['A', 'C', 'D'] >>> tokenize_peptide('R_mRGD') ['R_m', 'R', 'G', 'D'] >>> tokenize_peptide('AXR') Traceback (most recent call last): ... ValueError: Unknown amino acid(s) in peptide: {'X'} >>> tokenize_peptide('A_C_D') Traceback (most recent call last): ... ValueError: Unknown amino acid(s) in peptide: {'A_C_D'} \"\"\" if \"_\" not in peptide : tokens = list ( peptide ) diff = set ( tokens ) . difference ( __AAs ) if len ( diff ) > 0 : raise ValueError ( \"Unknown amino acid(s) in peptide: \" + str ( diff )) return tokens seq_len = len ( peptide ) tokens = list () char_ix = 0 while char_ix < seq_len : char = peptide [ char_ix ] if char == \"_\" : tokens [ - 1 ] = tokens [ - 1 ] + char + peptide [ char_ix + 1 ] char_ix = char_ix + 2 else : tokens . append ( char ) char_ix = char_ix + 1 diff = set ( tokens ) . difference ( __AAs ) if len ( diff ) > 0 : raise ValueError ( \"Unknown amino acid(s) in peptide: \" + str ( diff )) return tokens","title":"tokenize_peptide()"}]}